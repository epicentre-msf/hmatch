<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Match a hierarchical column (e.g. region, province, or county) within a raw,
potentially messy dataset against a corresponding column within a reference
dataset, by searching for similar sets of 'offspring' (i.e. values at the
next hierarchical level).
For example, if the raw dataset uses admin1 level &quot;NY&quot; whereas the reference
dataset uses &quot;New York&quot;, it would be difficult to automatically match these
values using only fuzzy-matching. However, we might nonetheless be able to
match &quot;NY&quot; to &quot;New York&quot; if they share a common and unique set of 'offspring'
(i.e. admin2 values) across both datasets (e.g &quot;Kings&quot;, &quot;Queens&quot;, &quot;New York&quot;,
&quot;Suffolk&quot;, &quot;Bronx&quot;, etc.).
Unlike other hmatch functions, the data frame returned by hmatch_parents
only includes unique hierarchical combinations and only relevant
hierarchical levels (i.e. the parent level and above), along with additional
columns giving the number of matching children and total number of children
for a given parent."><title>Hierarchical matching of parents based on sets of common offspring — hmatch_parents • hmatch</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Hierarchical matching of parents based on sets of common offspring — hmatch_parents"><meta property="og:description" content="Match a hierarchical column (e.g. region, province, or county) within a raw,
potentially messy dataset against a corresponding column within a reference
dataset, by searching for similar sets of 'offspring' (i.e. values at the
next hierarchical level).
For example, if the raw dataset uses admin1 level &quot;NY&quot; whereas the reference
dataset uses &quot;New York&quot;, it would be difficult to automatically match these
values using only fuzzy-matching. However, we might nonetheless be able to
match &quot;NY&quot; to &quot;New York&quot; if they share a common and unique set of 'offspring'
(i.e. admin2 values) across both datasets (e.g &quot;Kings&quot;, &quot;Queens&quot;, &quot;New York&quot;,
&quot;Suffolk&quot;, &quot;Bronx&quot;, etc.).
Unlike other hmatch functions, the data frame returned by hmatch_parents
only includes unique hierarchical combinations and only relevant
hierarchical levels (i.e. the parent level and above), along with additional
columns giving the number of matching children and total number of children
for a given parent."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">hmatch</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/epicentre-msf/hmatch/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Hierarchical matching of parents based on sets of common offspring</h1>
      <small class="dont-index">Source: <a href="https://github.com/epicentre-msf/hmatch/blob/HEAD/R/hmatch_parents.R" class="external-link"><code>R/hmatch_parents.R</code></a></small>
      <div class="d-none name"><code>hmatch_parents.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Match a hierarchical column (e.g. region, province, or county) within a raw,
potentially messy dataset against a corresponding column within a reference
dataset, by searching for similar sets of 'offspring' (i.e. values at the
next hierarchical level).</p>
<p>For example, if the raw dataset uses admin1 level "NY" whereas the reference
dataset uses "New York", it would be difficult to automatically match these
values using only fuzzy-matching. However, we might nonetheless be able to
match "NY" to "New York" if they share a common and unique set of 'offspring'
(i.e. admin2 values) across both datasets (e.g "Kings", "Queens", "New York",
"Suffolk", "Bronx", etc.).</p>
<p>Unlike other <code>hmatch</code> functions, the data frame returned by <code>hmatch_parents</code>
only includes <em>unique</em> hierarchical combinations and only relevant
hierarchical levels (i.e. the parent level and above), along with additional
columns giving the number of matching children and total number of children
for a given parent.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">hmatch_parents</span><span class="op">(</span></span>
<span>  <span class="va">raw</span>,</span>
<span>  <span class="va">ref</span>,</span>
<span>  <span class="va">pattern</span>,</span>
<span>  pattern_ref <span class="op">=</span> <span class="va">pattern</span>,</span>
<span>  <span class="va">by</span>,</span>
<span>  by_ref <span class="op">=</span> <span class="va">by</span>,</span>
<span>  <span class="va">level</span>,</span>
<span>  min_matches <span class="op">=</span> <span class="fl">1L</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"left"</span>,</span>
<span>  fuzzy <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  fuzzy_method <span class="op">=</span> <span class="st">"osa"</span>,</span>
<span>  fuzzy_dist <span class="op">=</span> <span class="fl">1L</span>,</span>
<span>  ref_prefix <span class="op">=</span> <span class="st">"ref_"</span>,</span>
<span>  std_fn <span class="op">=</span> <span class="va">string_std</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>raw</dt>
<dd><p>data frame containing hierarchical columns with raw data</p></dd>


<dt>ref</dt>
<dd><p>data frame containing hierarchical columns with reference data</p></dd>


<dt>pattern</dt>
<dd><p>regex pattern to match the hierarchical columns in <code>raw</code><br></p>
<p><strong>Note:</strong> hierarchical column names can be matched using either the <code>pattern</code>
<em>or</em> <code>by</code> arguments. Or, if neither <code>pattern</code> or <code>by</code> are specified, the
hierarchical columns are assumed to be all column names that are common to
both <code>raw</code> and <code>ref</code>. See <a href="specifying_columns.html">specifying_columns</a>.</p></dd>


<dt>pattern_ref</dt>
<dd><p>regex pattern to match the hierarchical columns in <code>ref</code>.
Defaults to <code>pattern</code>, so only need to specify if the hierarchical columns
have different names in <code>raw</code> and <code>ref</code>.</p></dd>


<dt>by</dt>
<dd><p>vector giving the names of the hierarchical columns in <code>raw</code></p></dd>


<dt>by_ref</dt>
<dd><p>vector giving the names of the hierarchical columns in <code>ref</code>.
Defaults to <code>by</code>, so only need to specify if the hierarchical columns
have different names in <code>raw</code> and <code>ref</code>.</p></dd>


<dt>level</dt>
<dd><p>name or integer index of the hierarchical level to match at
(i.e. the 'parent' level). If a name, must correspond to a hierarchical
column within <code>raw</code>, not including the very last hierarchical column (which
has no hierarchical children). If an integer, must be between 1 and k-1,
where k is the number of hierarchical columns.</p></dd>


<dt>min_matches</dt>
<dd><p>minimum number of matching offspring required for parents
to be considered a match. Defaults to <code>1</code>.</p></dd>


<dt>type</dt>
<dd><p>type of join ("left", "inner" or "anti") (defaults to "left")</p></dd>


<dt>fuzzy</dt>
<dd><p>logical indicating whether to use fuzzy-matching (based on the
<code>stringdist</code> package). Defaults to FALSE.</p></dd>


<dt>fuzzy_method</dt>
<dd><p>if <code>fuzzy = TRUE</code>, the method to use for string distance
calculation (see <a href="https://rdrr.io/pkg/stringdist/man/stringdist-metrics.html" class="external-link">stringdist-metrics</a>). Defaults to "osa".</p></dd>


<dt>fuzzy_dist</dt>
<dd><p>if <code>fuzzy = TRUE</code>, the maximum string distance to use to
classify matches (i.e. a string distance less than or equal to <code>fuzzy_dist</code>
will be considered matching). Defaults to <code>1L</code>.</p></dd>


<dt>ref_prefix</dt>
<dd><p>prefix to add to names of returned columns from <code>ref</code> if
they are otherwise identical to names within <code>raw</code>. Defaults to "ref_".</p></dd>


<dt>std_fn</dt>
<dd><p>function to standardize strings during matching. Defaults to
<code><a href="string_std.html">string_std</a></code>. Set to <code>NULL</code> to omit standardization. See
also <a href="string_standardization.html">string_standardization</a>.</p></dd>


<dt>...</dt>
<dd><p>additional arguments passed to <code>std_fn()</code></p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>a data frame obtained by matching the hierarchical columns in <code>raw</code></p>


<p>and <code>ref</code> (at the parent level and above), using the join type specified by
argument <code>type</code> (see <a href="join_types.html">join_types</a> for more details). Note that unlike
other <code>hmatch_</code> functions, hmatch_parents returns only unique rows and
relevant hierarchical columns (i.e. the parent level and above), along with
additional columns describing the number of matching children and total
number of children for a given parent.</p>
<dl><dt>...</dt>
<dd><p>hierarchical columns from <code>raw</code>, parent level and above</p></dd>

<dt>...</dt>
<dd><p>hierarchical columns from <code>ref</code>, parent level and above</p></dd>

<dt>n_child_raw</dt>
<dd><p>total number of unique children belonging to the parent within <code>raw</code></p></dd>

<dt>n_child_ref</dt>
<dd><p>total number of unique children belonging to the parent within <code>ref</code></p></dd>

<dt>n_child_match</dt>
<dd><p>number of children in <code>raw</code> with match in <code>ref</code></p></dd>

</dl></div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># e.g. match abbreviated adm1 names to full names based on common offspring</span></span></span>
<span class="r-in"><span><span class="va">raw</span> <span class="op">&lt;-</span> <span class="va">ne_ref</span></span></span>
<span class="r-in"><span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span><span class="op">[</span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span> <span class="op">==</span> <span class="st">"Ontario"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"ON"</span></span></span>
<span class="r-in"><span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span><span class="op">[</span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span> <span class="op">==</span> <span class="st">"New York"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"NY"</span></span></span>
<span class="r-in"><span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span><span class="op">[</span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span> <span class="op">==</span> <span class="st">"New Jersey"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"NJ"</span></span></span>
<span class="r-in"><span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span><span class="op">[</span><span class="va">raw</span><span class="op">$</span><span class="va">adm1</span> <span class="op">==</span> <span class="st">"Pennsylvania"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"PA"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu">hmatch_parents</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">raw</span>,</span></span>
<span class="r-in"><span>  <span class="va">ne_ref</span>,</span></span>
<span class="r-in"><span>  pattern <span class="op">=</span> <span class="st">"adm"</span>,</span></span>
<span class="r-in"><span>  level <span class="op">=</span> <span class="st">"adm1"</span>,</span></span>
<span class="r-in"><span>  min_matches <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  type <span class="op">=</span> <span class="st">"left"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   adm0 adm1 ref_adm0     ref_adm1 n_child_raw n_child_ref n_child_match</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1  CAN   ON      CAN      Ontario           5           5             5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2  USA   NJ      USA   New Jersey           5           5             5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3  USA   NY      USA     New York           7           7             7</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 4  USA   PA      USA Pennsylvania           8           8             8</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Patrick Barks.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

