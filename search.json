[{"path":"https://epicentre-msf.github.io/hmatch/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Patrick Barks. Author, maintainer. Paul Campbell. Contributor.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Barks P (2023). hmatch: Tools Cleaning Matching Hierarchically-Structured Data. R package version 0.1.0.9000, https://github.com/epicentre-msf/hmatch.","code":"@Manual{,   title = {hmatch: Tools for Cleaning and Matching Hierarchically-Structured Data},   author = {Patrick Barks},   year = {2023},   note = {R package version 0.1.0.9000},   url = {https://github.com/epicentre-msf/hmatch}, }"},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"hmatch-tools-for-cleaning-and-matching-hierarchically-structured-data","dir":"","previous_headings":"","what":"Tools for Cleaning and Matching Hierarchically-Structured Data","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"R package cleaning matching messy hierarchically-structured data (e.g. country / region / district / municipality). general goal match sets hierarchical values raw dataset corresponding values within reference dataset, accounting potential discrepancies : variation character case, punctuation, spacing, use accents, spelling variation hierarchical resolution (e.g. entries specified municipality-level others region) missing values one hierarchical levels values entered wrong hierarchical level","code":""},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"Install GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"epicentre-msf/hmatch\")"},{"path":[]},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"low-level","dir":"","previous_headings":"Matching strategies","what":"Low-level","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"hmatch: match hierarchical sequences highest-resolution level specified within given row raw data, optionally allowing missing values match level, fuzzy matches (using stringdist package)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"higher-level","dir":"","previous_headings":"Matching strategies","what":"Higher-level","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"hmatch_tokens: match tokens rather entire strings allow variation multi-term names hmatch_permute: sequentially permute hierarchical columns allow values entered wrong level hmatch_parents: match values given hierarchical level based shared sets ‘offspring’ hmatch_settle: try matching every level settle highest-resolution match possible hmatch_manual: match using user-supplied dictionary hmatch_split: implement hmatch_ function separately hierarchical level, unique sequences hmatch_composite: implement variety matching strategies sequence, least strict","code":""},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"string-standardization","dir":"","previous_headings":"","what":"String standardization","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"Independent optional fuzzy matching stringdist, hmatch functions use behind--scenes string standardization help account variation character case, punctuation, spacing, use accents raw reference data. E.g. Users can choose default standardization (illustrated ), standardization, supply preferred function standardize strings (e.g. tolower).","code":"raw_value       reference_value  match ---------------------------------------------------- original:     ILE DE  FRANCE  Île-de-France    FALSE standardized: ile_de_france   ile_de_france    TRUE"},{"path":[]},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"example-dataset","dir":"","previous_headings":"Usage","what":"Example dataset","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"hmatch package contains example datasets ne_raw (messy geographical data) ne_ref (reference data derived shapefile), based small subset northeastern North America.","code":"library(hmatch)  head(ne_raw) # raw messy data #>      id adm0      adm1         adm2 #> 1 PID01  USA  New York      Suffolk #> 2 PID02  can   ontario         <NA> #> 3 PID03  USA  New York Kings County #> 4 PID04 <NA>      <NA> Philadelphia #> 5 PID05  USA      <NA>         York #> 6 PID06  USA new. york    jefferson  head(ne_ref) # reference data derived from shapefile #>   level adm0         adm1 adm2 hcode #> 1  adm0  CAN         <NA> <NA>   100 #> 2  adm0  USA         <NA> <NA>   200 #> 3  adm1  CAN      Ontario <NA>   110 #> 4  adm1  USA   New Jersey <NA>   210 #> 5  adm1  USA     New York <NA>   220 #> 6  adm1  USA Pennsylvania <NA>   230"},{"path":[]},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"basic-hierarchical-matching-with-hmatch","dir":"","previous_headings":"Usage > Example workflow","what":"Basic hierarchical matching with hmatch()","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"’ll start simple call hmatch see rows can matched extra magic. still quite unmatched rows, entry ‘PID14’ actually matches two different rows within ref, ’ll press . can separate matched unmatched rows using inner- anti-joins respectively, specifically using “resolve_” join type consider matches unique.","code":"hmatch(ne_raw, ne_ref, pattern = \"^adm\") #>       id adm0           adm1         adm2 level ref_adm0     ref_adm1     ref_adm2 hcode #> 1  PID01  USA       New York      Suffolk  adm2      USA     New York      Suffolk   227 #> 2  PID02  can        ontario         <NA>  adm1      CAN      Ontario         <NA>   110 #> 3  PID03  USA       New York Kings County  <NA>     <NA>         <NA>         <NA>  <NA> #> 4  PID04 <NA>           <NA> Philadelphia  adm2      USA Pennsylvania Philadelphia   237 #> 5  PID05  USA           <NA>         York  adm2      USA Pennsylvania         York   238 #> 6  PID06  USA      new. york    jefferson  adm2      USA     New York    Jefferson   222 #> 7  PID07  CAN        Ontario    Peel R.M.  <NA>     <NA>         <NA>         <NA>  <NA> #> 8  PID08  USA    Pensylvania       Ithaca  <NA>     <NA>         <NA>         <NA>  <NA> #> 9  PID09  USA       New_York         King  <NA>     <NA>         <NA>         <NA>  <NA> #> 10 PID10 <NA>           <NA> Bergen, N.J.  <NA>     <NA>         <NA>         <NA>  <NA> #> 11 PID11  USA   Philadelphia         <NA>  <NA>     <NA>         <NA>         <NA>  <NA> #> 12 PID12  USA             NJ         <NA>  <NA>     <NA>         <NA>         <NA>  <NA> #> 13 PID13 <NA>           <NA>    Jeffersen  <NA>     <NA>         <NA>         <NA>  <NA> #> 14 PID14 <NA>           <NA>         york  adm2      CAN      Ontario         York   115 #> 15 PID14 <NA>           <NA>         york  adm2      USA Pennsylvania         York   238 #> 16 PID15  USA New York State     New York  <NA>     <NA>         <NA>         <NA>  <NA> (raw_match1 <- hmatch(ne_raw, ne_ref, pattern = \"^adm\", type = \"resolve_inner\")) #>      id adm0      adm1         adm2 level ref_adm0     ref_adm1     ref_adm2 hcode #> 1 PID01  USA  New York      Suffolk  adm2      USA     New York      Suffolk   227 #> 2 PID02  can   ontario         <NA>  adm1      CAN      Ontario         <NA>   110 #> 3 PID04 <NA>      <NA> Philadelphia  adm2      USA Pennsylvania Philadelphia   237 #> 4 PID05  USA      <NA>         York  adm2      USA Pennsylvania         York   238 #> 5 PID06  USA new. york    jefferson  adm2      USA     New York    Jefferson   222  (raw_remain1 <- hmatch(ne_raw, ne_ref, pattern = \"^adm\", type = \"resolve_anti\")) #>       id adm0           adm1         adm2 #> 1  PID03  USA       New York Kings County #> 2  PID07  CAN        Ontario    Peel R.M. #> 3  PID08  USA    Pensylvania       Ithaca #> 4  PID09  USA       New_York         King #> 5  PID10 <NA>           <NA> Bergen, N.J. #> 6  PID11  USA   Philadelphia         <NA> #> 7  PID12  USA             NJ         <NA> #> 8  PID13 <NA>           <NA>    Jeffersen #> 9  PID14 <NA>           <NA>         york #> 10 PID15  USA New York State     New York"},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"fuzzy-matching","dir":"","previous_headings":"Usage > Example workflow","what":"Fuzzy matching","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"Next ’ll add fuzzy-matching, using default maximum string-distance 1. one additional unique match, ’ll split move . Note ’ve using pattern argument specify hierarchical columns raw ref, hierarchical columns names raw ref (matching column names), can drop pattern argument brevity.","code":"hmatch(raw_remain1, ne_ref, pattern = \"^adm\", fuzzy = TRUE, type = \"inner\") #>      id adm0     adm1      adm2 level ref_adm0     ref_adm1  ref_adm2 hcode #> 1 PID09  USA New_York      King  adm2      USA     New York     Kings   223 #> 2 PID13 <NA>     <NA> Jeffersen  adm2      USA     New York Jefferson   222 #> 3 PID13 <NA>     <NA> Jeffersen  adm2      USA Pennsylvania Jefferson   235 #> 4 PID14 <NA>     <NA>      york  adm2      CAN      Ontario      York   115 #> 5 PID14 <NA>     <NA>      york  adm2      USA Pennsylvania      York   238 (raw_match2 <- hmatch(raw_remain1, ne_ref, fuzzy = TRUE, type = \"resolve_inner\")) #>      id adm0     adm1 adm2 level ref_adm0 ref_adm1 ref_adm2 hcode #> 1 PID09  USA New_York King  adm2      USA New York    Kings   223  (raw_remain2 <- hmatch(raw_remain1, ne_ref, fuzzy = TRUE, type = \"resolve_anti\")) #>      id adm0           adm1         adm2 #> 1 PID03  USA       New York Kings County #> 2 PID07  CAN        Ontario    Peel R.M. #> 3 PID08  USA    Pensylvania       Ithaca #> 4 PID10 <NA>           <NA> Bergen, N.J. #> 5 PID11  USA   Philadelphia         <NA> #> 6 PID12  USA             NJ         <NA> #> 7 PID13 <NA>           <NA>    Jeffersen #> 8 PID14 <NA>           <NA>         york #> 9 PID15  USA New York State     New York"},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"tokenized-matching","dir":"","previous_headings":"Usage > Example workflow","what":"Tokenized matching","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"Next let’s try hmatch_tokens, matches based components strings (.e. tokens) rather entire strings.","code":"(raw_match3 <- hmatch_tokens(raw_remain2, ne_ref, type = \"resolve_inner\")) #>      id adm0           adm1         adm2 level ref_adm0   ref_adm1 ref_adm2 hcode #> 1 PID03  USA       New York Kings County  adm2      USA   New York    Kings   223 #> 2 PID07  CAN        Ontario    Peel R.M.  adm2      CAN    Ontario     Peel   113 #> 3 PID10 <NA>           <NA> Bergen, N.J.  adm2      USA New Jersey   Bergen   211 #> 4 PID15  USA New York State     New York  adm2      USA   New York New York   225  (raw_remain3 <- hmatch_tokens(raw_remain2, ne_ref, type = \"resolve_anti\")) #>      id adm0         adm1      adm2 #> 1 PID08  USA  Pensylvania    Ithaca #> 2 PID11  USA Philadelphia      <NA> #> 3 PID12  USA           NJ      <NA> #> 4 PID13 <NA>         <NA> Jeffersen #> 5 PID14 <NA>         <NA>      york"},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"permutation-matching","dir":"","previous_headings":"Usage > Example workflow","what":"Permutation matching","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"values entered wrong hierarchical level, can try systematically permuting hierarchical columns matching.","code":"(raw_match4 <- hmatch_permute(raw_remain3, ne_ref, type = \"resolve_inner\")) #>      id adm0         adm1 adm2 level ref_adm0     ref_adm1     ref_adm2 hcode #> 1 PID11  USA Philadelphia <NA>  adm2      USA Pennsylvania Philadelphia   237  (raw_remain4 <- hmatch_permute(raw_remain3, ne_ref, type = \"resolve_anti\")) #>      id adm0        adm1      adm2 #> 1 PID08  USA Pensylvania    Ithaca #> 2 PID12  USA          NJ      <NA> #> 3 PID13 <NA>        <NA> Jeffersen #> 4 PID14 <NA>        <NA>      york"},{"path":"https://epicentre-msf.github.io/hmatch/index.html","id":"the-toughest-cases","dir":"","previous_headings":"Usage > Example workflow","what":"The toughest cases","title":"Tools for Cleaning and Matching Hierarchically-Structured Data","text":"remaining rows haven’t yet matched, options. use hmatch_settle() settle matches highest-resolution level specified within given row raw. also ‘manual’ comparison raw reference datasets create dictionary recode values within raw match corresponding entries ref. ’ll .","code":"ne_dict <- data.frame(   value = \"NJ\",   replacement = \"New Jersey\",   variable = \"adm1\" )  (raw_match5 <- hmatch_settle(raw_remain4, ne_ref, dict = ne_dict,                              fuzzy = TRUE, type = \"resolve_inner\")) #>      id adm0        adm1      adm2 level ref_adm0     ref_adm1 ref_adm2 hcode #> 1 PID08  USA Pensylvania    Ithaca  adm1      USA Pennsylvania     <NA>   230 #> 2 PID12  USA          NJ      <NA>  adm1      USA   New Jersey     <NA>   210 #> 3 PID13 <NA>        <NA> Jeffersen  adm2      USA         <NA>     <NA>   222  (raw_remain5 <- hmatch_settle(raw_remain4, ne_ref, dict = ne_dict,                               fuzzy = TRUE, type = \"resolve_anti\")) #>      id adm0 adm1 adm2 #> 1 PID14 <NA> <NA> york"},{"path":"https://epicentre-msf.github.io/hmatch/reference/count_tokens.html","id":null,"dir":"Reference","previous_headings":"","what":"Find frequently occurring tokens within a hierarchical column — count_tokens","title":"Find frequently occurring tokens within a hierarchical column — count_tokens","text":"Tokenized matching hierarchical columns can yield false positives tokens occur frequently multiple unique hierarchical values (e.g. \"South\", \"North\", \"City\", etc.). helper function find frequently-occurring tokens, can passed exclude argument hmatch_tokens. frequency calculated number unique, string-standardized values given token found.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/count_tokens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find frequently occurring tokens within a hierarchical column — count_tokens","text":"","code":"count_tokens(   x,   split = \"[-_[:space:]]+\",   min_freq = 2,   min_nchar = 3,   return_values = TRUE,   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/count_tokens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find frequently occurring tokens within a hierarchical column — count_tokens","text":"x character vector (generally hierarchical column) split regex pattern used split values tokens. default splits sequence one space characters (\"[:space:]\"), dashes (\"-\"), /underscores (\"_\"). min_freq minimum token frequency (.e. number unique values given token occurs). Defaults 2. min_nchar minimum token size number characters. Defaults 3. return_values logical indicating whether return standardized values token found (TRUE), count number unique standardized values (FALSE). Defaults TRUE. std_fn function standardize strings, performed within hmatch_ functions. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/count_tokens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find frequently occurring tokens within a hierarchical column — count_tokens","text":"","code":"french_departments <- c(   \"Alpes-de-Haute-Provence\", \"Hautes-Alpes\", \"Ardennes\", \"Bouches-du-Rhône\",   \"Corse-du-Sud\", \"Haute-Corse\", \"Haute-Garonne\", \"Ille-et-Vilaine\",   \"Haute-Loire\", \"Hautes-Pyrénées\", \"Pyrénées-Atlantiques\", \"Hauts-de-Seine\" )  count_tokens(french_departments) #>    token_std               value_std #> 1      haute alpes_de_haute_provence #> 2      haute             haute_corse #> 3      haute           haute_garonne #> 4      haute             haute_loire #> 5      alpes alpes_de_haute_provence #> 6      alpes            hautes_alpes #> 7      corse            corse_du_sud #> 8      corse             haute_corse #> 9     hautes            hautes_alpes #> 10    hautes         hautes_pyrenees #> 11  pyrenees         hautes_pyrenees #> 12  pyrenees    pyrenees_atlantiques"},{"path":"https://epicentre-msf.github.io/hmatch/reference/dictionary_recoding.html","id":null,"dir":"Reference","previous_headings":"","what":"Dictionary-based recoding of values during hierarchical matching — dictionary_recoding","title":"Dictionary-based recoding of values during hierarchical matching — dictionary_recoding","text":"hierarchical matching hmatch_ group functions, values within raw can temporarily recoded match values within ref based dictionary (argument dict) maps raw values desired replacement values (optionally limited given hierarchical column). Note recoding done internally, actually modify values raw returned (just enables match proper values ref). example, raw data contains entries \"USA\" variable \"adm0\", know correspond value \"United States\" within reference data, can specify dictionary follows: dict <- data.frame(value = \"USA\", replacement = \"United States\", variable = \"adm0\") column names dictionary actually matter, column order must : value raw temporarily replace replacement value (match value ref) (optional) name hierarchical column raw recode","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/dictionary_recoding.html","id":"specifying-column-s-to-recode","dir":"Reference","previous_headings":"","what":"Specifying column(s) to recode","title":"Dictionary-based recoding of values during hierarchical matching — dictionary_recoding","text":"dictionary contains two columns (values replacements), recoding applied every hierarchical column. apply portion dictionary hierarchical columns (rest specified columns), user can specify third dictionary column values <NA> rows recoding apply hierarchical columns. E.g. dict <- data.frame(value = c(\"USA\", \"Washingtin\" replace = c(\"United States\", \"Washington\"), variable = c(\"adm0\", NA)) example, dictionary specifies values \"USA\" within column \"adm0\" temporarily replaced \"United States\", values \"Washingtin\" within hierarchical column replaced \"Washington\".","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/dictionary_recoding.html","id":"string-standardization","dir":"Reference","previous_headings":"","what":"String standardization","title":"Dictionary-based recoding of values during hierarchical matching — dictionary_recoding","text":"Note string standardization specifed argument std_fn (see string_standardization) also applies dictionaries. example, given default standardization function includes case-standardization, dictionary value \"USA\" match (therefore recode) raw enries \"USA\" \"usa\", e.g. \"U.S..\".","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hcodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Create codes to identify each unique combination of hierarchical levels in\na reference dataset — hcodes","title":"Create codes to identify each unique combination of hierarchical levels in\na reference dataset — hcodes","text":"Create codes identify unique combination hierarchical levels reference dataset. Codes may integer-based (function hcodes_int) string-based (hcodes_str). Integer-based codes reflect alphabetical ranking level within next-highest level. constant-width may optionally prefixed given string. String-based codes created pasting together values hierarchical level given separator (options string standardization prior collapsing).","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hcodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create codes to identify each unique combination of hierarchical levels in\na reference dataset — hcodes","text":"","code":"hcodes_str(ref, pattern, by, sep = \"__\", std_fn = string_std)  hcodes_int(ref, pattern, by, prefix = \"\")"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hcodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create codes to identify each unique combination of hierarchical levels in\na reference dataset — hcodes","text":"ref data.frame containing hierarchical columns reference data pattern regex pattern match names hierarchical columns ref (supply either pattern ) vector giving names hierarchical columns ref (supply either pattern ) sep (hcodes_str) desired separator levels string-based codes (defaults \"__\") std_fn (hcodes_str) Function standardize input strings prior creating codes. Defaults string_std. Set NULL omit standardization. See also string_standardization. prefix (hcodes_int) character prefix integer-based codes (defaults \"\")","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hcodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create codes to identify each unique combination of hierarchical levels in\na reference dataset — hcodes","text":"vector codes","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hcodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create codes to identify each unique combination of hierarchical levels in\na reference dataset — hcodes","text":"","code":"data(ne_ref)  # string-based codes hcodes_str(ne_ref, pattern = \"^adm\") #>  [1] \"can\"                             \"usa\"                             #>  [3] \"can__ontario\"                    \"usa__new_jersey\"                 #>  [5] \"usa__new_york\"                   \"usa__pennsylvania\"               #>  [7] \"can__ontario__durham\"            \"can__ontario__halton\"            #>  [9] \"can__ontario__peel\"              \"can__ontario__toronto\"           #> [11] \"can__ontario__york\"              \"usa__new_jersey__bergen\"         #> [13] \"usa__new_jersey__essex\"          \"usa__new_jersey__hudson\"         #> [15] \"usa__new_jersey__middlesex\"      \"usa__new_jersey__monmouth\"       #> [17] \"usa__new_york__jefferson\"        \"usa__new_york__bronx\"            #> [19] \"usa__new_york__kings\"            \"usa__new_york__nassau\"           #> [21] \"usa__new_york__new_york\"         \"usa__new_york__queens\"           #> [23] \"usa__new_york__suffolk\"          \"usa__pennsylvania__allegheny\"    #> [25] \"usa__pennsylvania__bucks\"        \"usa__pennsylvania__chester\"      #> [27] \"usa__pennsylvania__delaware\"     \"usa__pennsylvania__jefferson\"    #> [29] \"usa__pennsylvania__lancaster\"    \"usa__pennsylvania__philadelphia\" #> [31] \"usa__pennsylvania__york\"          # integer-based codes hcodes_int(ne_ref, pattern = \"^adm\") #>  [1] \"100\" \"200\" \"110\" \"210\" \"220\" \"230\" \"111\" \"112\" \"113\" \"114\" \"115\" \"211\" #> [13] \"212\" \"213\" \"214\" \"215\" \"222\" \"221\" \"223\" \"224\" \"225\" \"226\" \"227\" \"231\" #> [25] \"232\" \"233\" \"234\" \"235\" \"236\" \"237\" \"238\""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","title":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","text":"Match sets hierarchical values (e.g. province, county, township) raw, messy dataset corresponding values within reference dataset, optionally accounting discrepancies datasets : variation character case, use accents, spelling variation hierarchical resolution (e.g. entries specified municipality others region) missing values one hierarchical levels","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","text":"","code":"hmatch(   raw,   ref,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   type = \"left\",   allow_gaps = TRUE,   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   dict = NULL,   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data pattern regex pattern match hierarchical columns raw Note: hierarchical column names can matched using either pattern arguments. , neither pattern specified, hierarchical columns assumed column names common raw ref. See specifying_columns. pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. type type join (\"left\", \"inner\", \"anti\", \"resolve_left\", \"resolve_inner\", \"resolve_anti\"). Defaults \"left\". See join_types. allow_gaps logical indicating whether allow missing values match level, 'match level' highest level non-missing value within given row raw. Defaults TRUE. fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. dict optional dictionary recoding values within hierarchical columns raw (see dictionary_recoding) ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","text":"data frame obtained matching hierarchical columns raw ref, using join type specified argument type (see join_types details)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch.html","id":"resolve-joins","dir":"Reference","previous_headings":"","what":"Resolve joins","title":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","text":"hmatch, argument type corresponds resolve join, rows raw multiple matches ref always resolved 'match'. hmatch accept matches highest non-missing level within given row raw. E.g. raw: 1. | United States | <NA>         | Jefferson | Relevant rows ref: 1. | United States | New York     | Jefferson | 2. | United States | Pennsylvania | Jefferson | regular join hmatch, single row raw () match rows ref. However, resolve join multiple conflicting matches (.e. conflicting values 2nd hierarchical level) result row raw treated non-matching ref.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match sets of hierarchical variables between a raw and reference dataset — hmatch","text":"","code":"data(ne_raw) data(ne_ref)  hmatch(ne_raw, ne_ref, pattern = \"adm\", type = \"inner\") #>      id adm0      adm1         adm2 level ref_adm0     ref_adm1     ref_adm2 #> 1 PID01  USA  New York      Suffolk  adm2      USA     New York      Suffolk #> 2 PID02  can   ontario         <NA>  adm1      CAN      Ontario         <NA> #> 3 PID04 <NA>      <NA> Philadelphia  adm2      USA Pennsylvania Philadelphia #> 4 PID05  USA      <NA>         York  adm2      USA Pennsylvania         York #> 5 PID06  USA new. york    jefferson  adm2      USA     New York    Jefferson #> 6 PID14 <NA>      <NA>         york  adm2      CAN      Ontario         York #> 7 PID14 <NA>      <NA>         york  adm2      USA Pennsylvania         York #>   hcode #> 1   227 #> 2   110 #> 3   237 #> 4   238 #> 5   222 #> 6   115 #> 7   238"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_composite.html","id":null,"dir":"Reference","previous_headings":"","what":"Implement a variety of hierarchical matching strategies in sequence — hmatch_composite","title":"Implement a variety of hierarchical matching strategies in sequence — hmatch_composite","text":"Match data frame raw, potentially messy hierarchical data (e.g. province, county, township) reference dataset, using variety matching strategies implemented sequence identify best-possible match (.e. highest-resolution) row. sequence matching strategies : (optional) manually-specified matching hmatch_manual complete matching hmatch(..., allow_gaps = FALSE) partial matching hmatch(..., allow_gaps = TRUE) fuzzy partial matching hmatch(allow_gaps = TRUE, fuzzy = TRUE) best-possible matching hmatch_settle approach implement rows data single match already identified using previous approaches.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_composite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Implement a variety of hierarchical matching strategies in sequence — hmatch_composite","text":"","code":"hmatch_composite(   raw,   ref,   man,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   code_col,   type = \"resolve_left\",   allow_gaps = TRUE,   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   dict = NULL,   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_composite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Implement a variety of hierarchical matching strategies in sequence — hmatch_composite","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data man (optional) data frame manually-specified matches, relating given set hierarchical values code within ref values correspond pattern regex pattern match hierarchical columns raw (man given) (see also specifying_columns) pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw (man given) by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. code_col name code column containing codes matching ref man (required argument man given) type type join (\"resolve_left\", \"resolve_inner\", \"resolve_anti\"). Defaults \"left\". See join_types. allow_gaps logical indicating whether allow missing values match level, 'match level' highest level non-missing value within given row raw. Defaults TRUE. fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. dict optional dictionary recoding values within hierarchical columns raw (see dictionary_recoding) ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_composite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Implement a variety of hierarchical matching strategies in sequence — hmatch_composite","text":"data frame obtained matching hierarchical columns raw ref, using join type specified argument type (see join_types details)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_composite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Implement a variety of hierarchical matching strategies in sequence — hmatch_composite","text":"","code":"data(ne_raw) data(ne_ref)  hmatch_composite(ne_raw, ne_ref, fuzzy = TRUE) #>       id adm0           adm1         adm2 level ref_adm0     ref_adm1 #> 1  PID01  USA       New York      Suffolk  adm2      USA     New York #> 2  PID02  can        ontario         <NA>  adm1      CAN      Ontario #> 3  PID03  USA       New York Kings County  adm1      USA     New York #> 4  PID04 <NA>           <NA> Philadelphia  adm2      USA Pennsylvania #> 5  PID05  USA           <NA>         York  adm2      USA Pennsylvania #> 6  PID06  USA      new. york    jefferson  adm2      USA     New York #> 7  PID07  CAN        Ontario    Peel R.M.  adm1      CAN      Ontario #> 8  PID08  USA    Pensylvania       Ithaca  adm1      USA Pennsylvania #> 9  PID09  USA       New_York         King  adm2      USA     New York #> 10 PID10 <NA>           <NA> Bergen, N.J.  <NA>     <NA>         <NA> #> 11 PID11  USA   Philadelphia         <NA>  adm0      USA         <NA> #> 12 PID12  USA             NJ         <NA>  adm0      USA         <NA> #> 13 PID13 <NA>           <NA>    Jeffersen  adm0      USA         <NA> #> 14 PID14 <NA>           <NA>         york  <NA>     <NA>         <NA> #> 15 PID15  USA New York State     New York  adm0      USA         <NA> #>        ref_adm2 hcode match_type #> 1       Suffolk   227   complete #> 2          <NA>   110   complete #> 3          <NA>   220     settle #> 4  Philadelphia   237       gaps #> 5          York   238       gaps #> 6     Jefferson   222   complete #> 7          <NA>   110     settle #> 8          <NA>   230     settle #> 9         Kings   223      fuzzy #> 10         <NA>  <NA>       <NA> #> 11         <NA>   200     settle #> 12         <NA>   200     settle #> 13         <NA>   200     settle #> 14         <NA>  <NA>       <NA> #> 15         <NA>   200     settle"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Manual hierarchical matching — hmatch_manual","title":"Manual hierarchical matching — hmatch_manual","text":"Match data.frame raw, potentially messy hierarchical data (e.g. province, county, township) reference dataset, using dictionary manually-specified matches.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manual hierarchical matching — hmatch_manual","text":"","code":"hmatch_manual(   raw,   ref,   man,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   code_col,   type = \"left\",   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manual hierarchical matching — hmatch_manual","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data man data.frame manually-specified matches, relating given set hierarchical values code within ref values correspond pattern regex pattern match hierarchical columns raw man (see also specifying_columns) pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw man by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. code_col name code column containing codes matching ref man type type join (\"left\", \"inner\", \"anti\"). Defaults \"left\". See join_types. Note function allow 'resolve joins', unlike hmatch_ functions. ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manual hierarchical matching — hmatch_manual","text":"data frame obtained matching hierarchical columns raw ref based sets matches specified man, using join type specified argument type (see join_types details)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manual hierarchical matching — hmatch_manual","text":"","code":"data(ne_raw) data(ne_ref)  # create df mapping sets of raw hierarchical values to codes within ref ne_man <- data.frame(   adm0 = NA_character_,   adm1 = NA_character_,   adm2 = \"Bergen, N.J.\",   hcode = \"211\",   stringsAsFactors = FALSE )  # find manual matches hmatch_manual(ne_raw, ne_ref, ne_man, code_col = \"hcode\", type = \"inner\") #>      id adm0 adm1         adm2 level ref_adm0   ref_adm1 ref_adm2 hcode #> 1 PID10 <NA> <NA> Bergen, N.J.  adm2      USA New Jersey   Bergen   211"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_parents.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical matching of parents based on sets of common offspring — hmatch_parents","title":"Hierarchical matching of parents based on sets of common offspring — hmatch_parents","text":"Match hierarchical column (e.g. region, province, county) within raw, potentially messy dataset corresponding column within reference dataset, searching similar sets 'offspring' (.e. values next hierarchical level). example, raw dataset uses admin1 level \"NY\" whereas reference dataset uses \"New York\", difficult automatically match values using fuzzy-matching. However, might nonetheless able match \"NY\" \"New York\" share common unique set 'offspring' (.e. admin2 values) across datasets (e.g \"Kings\", \"Queens\", \"New York\", \"Suffolk\", \"Bronx\", etc.). Unlike hmatch functions, data frame returned hmatch_parents includes unique hierarchical combinations relevant hierarchical levels (.e. parent level ), along additional columns giving number matching children total number children given parent.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_parents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical matching of parents based on sets of common offspring — hmatch_parents","text":"","code":"hmatch_parents(   raw,   ref,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   level,   min_matches = 1L,   type = \"left\",   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_parents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical matching of parents based on sets of common offspring — hmatch_parents","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data pattern regex pattern match hierarchical columns raw Note: hierarchical column names can matched using either pattern arguments. , neither pattern specified, hierarchical columns assumed column names common raw ref. See specifying_columns. pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. level name integer index hierarchical level match (.e. 'parent' level). name, must correspond hierarchical column within raw, including last hierarchical column (hierarchical children). integer, must 1 k-1, k number hierarchical columns. min_matches minimum number matching offspring required parents considered match. Defaults 1. type type join (\"left\", \"inner\" \"anti\") (defaults \"left\") fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_parents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical matching of parents based on sets of common offspring — hmatch_parents","text":"data frame obtained matching hierarchical columns raw ref (parent level ), using join type specified argument type (see join_types details). Note unlike hmatch_ functions, hmatch_parents returns unique rows relevant hierarchical columns (.e. parent level ), along additional columns describing number matching children total number children given parent. ... hierarchical columns raw, parent level ... hierarchical columns ref, parent level n_child_raw total number unique children belonging parent within raw n_child_ref total number unique children belonging parent within ref n_child_match number children raw match ref","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_parents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical matching of parents based on sets of common offspring — hmatch_parents","text":"","code":"# e.g. match abbreviated adm1 names to full names based on common offspring raw <- ne_ref raw$adm1[raw$adm1 == \"Ontario\"] <- \"ON\" raw$adm1[raw$adm1 == \"New York\"] <- \"NY\" raw$adm1[raw$adm1 == \"New Jersey\"] <- \"NJ\" raw$adm1[raw$adm1 == \"Pennsylvania\"] <- \"PA\"  hmatch_parents(   raw,   ne_ref,   pattern = \"adm\",   level = \"adm1\",   min_matches = 2,   type = \"left\" ) #>   adm0 adm1 ref_adm0     ref_adm1 n_child_raw n_child_ref n_child_match #> 1  CAN   ON      CAN      Ontario           5           5             5 #> 2  USA   NJ      USA   New Jersey           5           5             5 #> 3  USA   NY      USA     New York           7           7             7 #> 4  USA   PA      USA Pennsylvania           8           8             8"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_permute.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","title":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","text":"Match data frame raw, potentially messy hierarchical data (e.g. province, county, township) reference dataset, using sequential permutation hierarchical columns allow values entered wrong hierarchical level. function calls hmatch possible permutation hierarchical columns, combines results. Rows raw yielding multiple matches ref can optionally resolved using resolve-type join (see section Resolve joins ).","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_permute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","text":"","code":"hmatch_permute(   raw,   ref,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   type = \"left\",   allow_gaps = TRUE,   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   dict = NULL,   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_permute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data pattern regex pattern match hierarchical columns raw Note: hierarchical column names can matched using either pattern arguments. , neither pattern specified, hierarchical columns assumed column names common raw ref. See specifying_columns. pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. type type join (\"left\", \"inner\", \"anti\", \"resolve_left\", \"resolve_inner\", \"resolve_anti\"). Defaults \"left\". See join_types. allow_gaps logical indicating whether allow missing values match level, 'match level' highest level non-missing value within given row raw. Defaults TRUE. fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. dict optional dictionary recoding values within hierarchical columns raw (see dictionary_recoding) ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_permute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","text":"data frame obtained matching hierarchical columns raw ref, using join type specified argument type (see join_types details)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_permute.html","id":"resolve-joins","dir":"Reference","previous_headings":"","what":"Resolve joins","title":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","text":"hmatch_permute, argument type corresponds resolve join, rows raw multiple matches ref resolved highest hierarchical level common among matches (match conflict first level). E.g. raw: 1. | United States | <NA>     | New York | Relevant rows ref: 1. | United States | New York | <NA>     | 2. | United States | New York | New York | regular join hmatch_permute, single row raw () match depicted rows ref. However, resolve join two matches resolve first row ref, reflects highest hierarchical level common matches.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_permute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical matching with sequential column permutation to allow for values\nentered at the wrong hierarchical level — hmatch_permute","text":"","code":"data(ne_raw) data(ne_ref)  hmatch_permute(ne_raw, ne_ref, pattern = \"^adm\", type = \"inner\") #>      id adm0         adm1         adm2 level ref_adm0     ref_adm1     ref_adm2 #> 1 PID01  USA     New York      Suffolk  adm2      USA     New York      Suffolk #> 2 PID02  can      ontario         <NA>  adm1      CAN      Ontario         <NA> #> 3 PID04 <NA>         <NA> Philadelphia  adm2      USA Pennsylvania Philadelphia #> 4 PID05  USA         <NA>         York  adm2      USA Pennsylvania         York #> 5 PID06  USA    new. york    jefferson  adm2      USA     New York    Jefferson #> 6 PID11  USA Philadelphia         <NA>  adm2      USA Pennsylvania Philadelphia #> 7 PID14 <NA>         <NA>         york  adm2      CAN      Ontario         York #> 8 PID14 <NA>         <NA>         york  adm2      USA Pennsylvania         York #>   hcode #> 1   227 #> 2   110 #> 3   237 #> 4   238 #> 5   222 #> 6   237 #> 7   115 #> 8   238"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_settle.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","title":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","text":"Match sets hierarchical values (e.g. province / county / township) raw, messy dataset corresponding values within reference dataset, sequentially hierarchical level. Specifically, implements hmatch successive hierarchical level, starting first level (lowest resolution), first second, first second third, etc. initial matching levels, users can optionally use resolve join 'settle' highest match possible row raw data, even match highest-resolution level specified.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_settle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","text":"","code":"hmatch_settle(   raw,   ref,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   type = \"left\",   allow_gaps = TRUE,   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   dict = NULL,   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_settle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data pattern regex pattern match hierarchical columns raw Note: hierarchical column names can matched using either pattern arguments. , neither pattern specified, hierarchical columns assumed column names common raw ref. See specifying_columns. pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. type type join (\"left\", \"inner\", \"anti\", \"resolve_left\", \"resolve_inner\", \"resolve_anti\"). Defaults \"left\". See join_types. allow_gaps logical indicating whether allow missing values match level, 'match level' highest level non-missing value within given row raw. Defaults TRUE. fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. dict optional dictionary recoding values within hierarchical columns raw (see dictionary_recoding) ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_settle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","text":"data frame obtained matching hierarchical columns raw ref, using join type specified argument type (see join_types details)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_settle.html","id":"resolve-joins","dir":"Reference","previous_headings":"","what":"Resolve joins","title":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","text":"resolve type join hmatch_settle, rows raw multiple matches ref resolved highest hierarchical level non-conflicting among matches (match conflict first level). E.g. raw: 1. | United States | <NA>         | Jefferson | Relevant rows ref: 1. | United States | <NA>         | <NA>      | 2. | United States | New York     | Jefferson | 3. | United States | Pennsylvania | Jefferson | regular join, single row raw () match three rows ref. However, resolve join multiple matches resolved first row ref, first hierarchical level (\"United States\") non-conflicting among possible matches. Note distinction \"common\" values given hierarchical level (.e. single unique value row) \"non-conflicting\" values (.e. single unique value missing value). E.g. raw: 1. | United States | New York | New York | Relevant rows ref: 1. | United States | <NA>     | <NA>     | 2. | United States | New York | <NA>     | 3. | United States | New York | New York | example , 1st hierarchical level (\"United States\") \"common\" matches, hierarchical levels \"non-conflicting\" (.e. row 2 hierarchical child row 1, row 3 child row 2), resolve-type match made 3rd row ref.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_settle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequential hierarchical matching at each hierarchical level, settling for the\nhighest resolution match that is possible for each row — hmatch_settle","text":"","code":"data(ne_raw) data(ne_ref)  # return matches at all levels hmatch_settle(ne_raw, ne_ref, pattern = \"^adm\", type = \"inner\") #>       id adm0           adm1         adm2 level ref_adm0     ref_adm1 #> 1  PID01  USA       New York      Suffolk  adm0      USA         <NA> #> 2  PID01  USA       New York      Suffolk  adm1      USA     New York #> 3  PID01  USA       New York      Suffolk  adm2      USA     New York #> 4  PID02  can        ontario         <NA>  adm0      CAN         <NA> #> 5  PID02  can        ontario         <NA>  adm1      CAN      Ontario #> 6  PID03  USA       New York Kings County  adm0      USA         <NA> #> 7  PID03  USA       New York Kings County  adm1      USA     New York #> 8  PID04 <NA>           <NA> Philadelphia  adm2      USA Pennsylvania #> 9  PID05  USA           <NA>         York  adm0      USA         <NA> #> 10 PID05  USA           <NA>         York  adm2      USA Pennsylvania #> 11 PID06  USA      new. york    jefferson  adm0      USA         <NA> #> 12 PID06  USA      new. york    jefferson  adm1      USA     New York #> 13 PID06  USA      new. york    jefferson  adm2      USA     New York #> 14 PID07  CAN        Ontario    Peel R.M.  adm0      CAN         <NA> #> 15 PID07  CAN        Ontario    Peel R.M.  adm1      CAN      Ontario #> 16 PID08  USA    Pensylvania       Ithaca  adm0      USA         <NA> #> 17 PID09  USA       New_York         King  adm0      USA         <NA> #> 18 PID09  USA       New_York         King  adm1      USA     New York #> 19 PID11  USA   Philadelphia         <NA>  adm0      USA         <NA> #> 20 PID12  USA             NJ         <NA>  adm0      USA         <NA> #> 21 PID14 <NA>           <NA>         york  adm2      CAN      Ontario #> 22 PID14 <NA>           <NA>         york  adm2      USA Pennsylvania #> 23 PID15  USA New York State     New York  adm0      USA         <NA> #>        ref_adm2 hcode #> 1          <NA>   200 #> 2          <NA>   220 #> 3       Suffolk   227 #> 4          <NA>   100 #> 5          <NA>   110 #> 6          <NA>   200 #> 7          <NA>   220 #> 8  Philadelphia   237 #> 9          <NA>   200 #> 10         York   238 #> 11         <NA>   200 #> 12         <NA>   220 #> 13    Jefferson   222 #> 14         <NA>   100 #> 15         <NA>   110 #> 16         <NA>   200 #> 17         <NA>   200 #> 18         <NA>   220 #> 19         <NA>   200 #> 20         <NA>   200 #> 21         York   115 #> 22         York   238 #> 23         <NA>   200  # use a resolve join to settle for the best possible match for each row hmatch_settle(ne_raw, ne_ref, pattern = \"^adm\", type = \"resolve_inner\") #>       id adm0           adm1         adm2 level ref_adm0     ref_adm1 #> 1  PID01  USA       New York      Suffolk  adm2      USA     New York #> 2  PID02  can        ontario         <NA>  adm1      CAN      Ontario #> 3  PID03  USA       New York Kings County  adm1      USA     New York #> 4  PID04 <NA>           <NA> Philadelphia  adm2      USA Pennsylvania #> 5  PID05  USA           <NA>         York  adm2      USA Pennsylvania #> 6  PID06  USA      new. york    jefferson  adm2      USA     New York #> 7  PID07  CAN        Ontario    Peel R.M.  adm1      CAN      Ontario #> 8  PID08  USA    Pensylvania       Ithaca  adm0      USA         <NA> #> 9  PID09  USA       New_York         King  adm1      USA     New York #> 10 PID11  USA   Philadelphia         <NA>  adm0      USA         <NA> #> 11 PID12  USA             NJ         <NA>  adm0      USA         <NA> #> 12 PID15  USA New York State     New York  adm0      USA         <NA> #>        ref_adm2 hcode #> 1       Suffolk   227 #> 2          <NA>   110 #> 3          <NA>   220 #> 4  Philadelphia   237 #> 5          York   238 #> 6     Jefferson   222 #> 7          <NA>   110 #> 8          <NA>   200 #> 9          <NA>   220 #> 10         <NA>   200 #> 11         <NA>   200 #> 12         <NA>   200"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_split.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical matching, separately at each hierarchical level — hmatch_split","title":"Hierarchical matching, separately at each hierarchical level — hmatch_split","text":"Implements hierarchical matching, separately hierarchical level within data. given level, raw data matched includes every unique combination values level interest. E.g. Level 1: | Canada        | | United States | Level 2: | Canada        | Ontario      | | United States | New York     | | United States | Pennsylvania | Level 3: | Canada        | Ontario      | Ottawa       | | Canada        | Ontario      | Toronto      | | United States | New York     | Bronx        | | United States | New York     | New York     | | United States | Pennsylvania | Philadelphia |","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_split.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical matching, separately at each hierarchical level — hmatch_split","text":"","code":"hmatch_split(   raw,   ref,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   fn = \"hmatch\",   type = \"left\",   allow_gaps = TRUE,   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   dict = NULL,   ref_prefix = \"ref_\",   std_fn = string_std,   ...,   levels = NULL,   always_list = FALSE,   man,   code_col,   always_tokenize = FALSE,   token_split = \"_\",   exclude_freq = 3,   exclude_nchar = 3,   exclude_values = NULL )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_split.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical matching, separately at each hierarchical level — hmatch_split","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data pattern regex pattern match hierarchical columns raw Note: hierarchical column names can matched using either pattern arguments. , neither pattern specified, hierarchical columns assumed column names common raw ref. See specifying_columns. pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. fn function use matching. Current options hmatch, hmatch_permute, hmatch_tokens, hmatch_settle, hmatch_composite. Defaults \"hmatch\". Note subsequent arguments relevant specific functions (e.g. exclude_ arguments relevant fn = \"hmatch_tokens\"). type type join (\"left\", \"inner\", \"anti\", \"resolve_left\", \"resolve_inner\", \"resolve_anti\"). Defaults \"left\". See join_types. Note details resolve joins vary somewhat among hmatch functions (see documentation relevant function), function hmatch_composite allows resolve joins. allow_gaps logical indicating whether allow missing values match level, 'match level' highest level non-missing value within given row raw. Defaults TRUE. fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. dict optional dictionary recoding values within hierarchical columns raw (see dictionary_recoding) ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn() levels vector names integer indices corresponding one hierarchical columns raw match . Defaults NULL case matches made hierarchical level. always_list logical indicating whether always return list, even argument levels specifies single match level. Defaults FALSE. man (optional) data frame manually-specified matches, relating given set hierarchical values code within ref values correspond code_col name code column containing codes matching ref man (required argument man given) always_tokenize logical indicating whether tokenize values prior matching (TRUE), first attempt non-tokenized matching hmatch tokenize values within raw (corresponding putative matches within ref) non-tokenized match (FALSE). Defaults FALSE. token_split regex pattern split strings tokens. Currently tokenization implemented string-standardizatipn argument std_fn (may change future version), regex pattern split standardized strings rather original strings. Defaults \"_\". exclude_freq exclude tokens matching frequency greater equal value. Refers number unique, string-standardized values given hierarchical level given token occurs, calculated count_tokens (separately raw ref). Defaults 3. exclude_nchar exclude tokens matching nchar less equal value. Defaults 3. exclude_values character vector additional tokens exclude matching. Subject string-standardizatipn argument std_fn.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_split.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical matching, separately at each hierarchical level — hmatch_split","text":"list data frames, returned call fn unique combination hierarchical values given hierarchical level. number elements list corresponds number hierarchical columns raw, , specified, number elements argument levels. However, always_list = FALSE length(levels) == 1, single data frame returned (.e. wrapped list).","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_split.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical matching, separately at each hierarchical level — hmatch_split","text":"","code":"data(ne_raw) data(ne_ref)  # by default calls fn `hmatch` separately for each hierarchical level hmatch_split(ne_raw, ne_ref) #> $adm0 #>   adm0 adm1 adm2 level ref_adm0 ref_adm1 ref_adm2 hcode #> 1  CAN <NA> <NA>  adm0      CAN     <NA>     <NA>   100 #> 2  USA <NA> <NA>  adm0      USA     <NA>     <NA>   200 #> 3  can <NA> <NA>  adm0      CAN     <NA>     <NA>   100 #>  #> $adm1 #>   adm0           adm1 adm2 level ref_adm0 ref_adm1 ref_adm2 hcode #> 1  CAN        Ontario <NA>  adm1      CAN  Ontario     <NA>   110 #> 2  USA             NJ <NA>  <NA>     <NA>     <NA>     <NA>  <NA> #> 3  USA       New York <NA>  adm1      USA New York     <NA>   220 #> 4  USA New York State <NA>  <NA>     <NA>     <NA>     <NA>  <NA> #> 5  USA       New_York <NA>  adm1      USA New York     <NA>   220 #> 6  USA    Pensylvania <NA>  <NA>     <NA>     <NA>     <NA>  <NA> #> 7  USA   Philadelphia <NA>  <NA>     <NA>     <NA>     <NA>  <NA> #> 8  USA      new. york <NA>  adm1      USA New York     <NA>   220 #> 9  can        ontario <NA>  adm1      CAN  Ontario     <NA>   110 #>  #> $adm2 #>    adm0           adm1         adm2 level ref_adm0     ref_adm1     ref_adm2 #> 1  <NA>           <NA> Bergen, N.J.  <NA>     <NA>         <NA>         <NA> #> 2  <NA>           <NA>    Jeffersen  <NA>     <NA>         <NA>         <NA> #> 3  <NA>           <NA> Philadelphia  adm2      USA Pennsylvania Philadelphia #> 4  <NA>           <NA>         york  adm2      CAN      Ontario         York #> 5  <NA>           <NA>         york  adm2      USA Pennsylvania         York #> 6   CAN        Ontario    Peel R.M.  <NA>     <NA>         <NA>         <NA> #> 7   USA           <NA>         York  adm2      USA Pennsylvania         York #> 8   USA       New York Kings County  <NA>     <NA>         <NA>         <NA> #> 9   USA       New York      Suffolk  adm2      USA     New York      Suffolk #> 10  USA New York State     New York  <NA>     <NA>         <NA>         <NA> #> 11  USA       New_York         King  <NA>     <NA>         <NA>         <NA> #> 12  USA    Pensylvania       Ithaca  <NA>     <NA>         <NA>         <NA> #> 13  USA      new. york    jefferson  adm2      USA     New York    Jefferson #>    hcode #> 1   <NA> #> 2   <NA> #> 3    237 #> 4    115 #> 5    238 #> 6   <NA> #> 7    238 #> 8   <NA> #> 9    227 #> 10  <NA> #> 11  <NA> #> 12  <NA> #> 13   222 #>   # can also specify other hmatch functions, and subsets of hierarchical levels hmatch_split(ne_raw, ne_ref, fn = \"hmatch_tokens\", levels = 2:3) #> $adm1 #>    adm0           adm1 adm2 level ref_adm0   ref_adm1 ref_adm2 hcode #> 1   CAN        Ontario <NA>  adm1      CAN    Ontario     <NA>   110 #> 2   USA             NJ <NA>  <NA>     <NA>       <NA>     <NA>  <NA> #> 3   USA       New York <NA>  adm1      USA New Jersey     <NA>   210 #> 4   USA       New York <NA>  adm1      USA   New York     <NA>   220 #> 5   USA New York State <NA>  adm1      USA New Jersey     <NA>   210 #> 6   USA New York State <NA>  adm1      USA   New York     <NA>   220 #> 7   USA       New_York <NA>  adm1      USA New Jersey     <NA>   210 #> 8   USA       New_York <NA>  adm1      USA   New York     <NA>   220 #> 9   USA    Pensylvania <NA>  <NA>     <NA>       <NA>     <NA>  <NA> #> 10  USA   Philadelphia <NA>  <NA>     <NA>       <NA>     <NA>  <NA> #> 11  USA      new. york <NA>  adm1      USA New Jersey     <NA>   210 #> 12  USA      new. york <NA>  adm1      USA   New York     <NA>   220 #> 13  can        ontario <NA>  adm1      CAN    Ontario     <NA>   110 #>  #> $adm2 #>    adm0           adm1         adm2 level ref_adm0     ref_adm1     ref_adm2 #> 1  <NA>           <NA> Bergen, N.J.  adm2      USA   New Jersey       Bergen #> 2  <NA>           <NA>    Jeffersen  <NA>     <NA>         <NA>         <NA> #> 3  <NA>           <NA> Philadelphia  adm2      USA Pennsylvania Philadelphia #> 4  <NA>           <NA>         york  adm2      CAN      Ontario         York #> 5  <NA>           <NA>         york  adm2      USA     New York     New York #> 6  <NA>           <NA>         york  adm2      USA Pennsylvania         York #> 7   CAN        Ontario    Peel R.M.  adm2      CAN      Ontario         Peel #> 8   USA           <NA>         York  adm2      USA     New York     New York #> 9   USA           <NA>         York  adm2      USA Pennsylvania         York #> 10  USA       New York Kings County  adm2      USA     New York        Kings #> 11  USA       New York      Suffolk  adm2      USA     New York      Suffolk #> 12  USA New York State     New York  adm2      USA     New York     New York #> 13  USA       New_York         King  <NA>     <NA>         <NA>         <NA> #> 14  USA    Pensylvania       Ithaca  <NA>     <NA>         <NA>         <NA> #> 15  USA      new. york    jefferson  adm2      USA     New York    Jefferson #>    hcode #> 1    211 #> 2   <NA> #> 3    237 #> 4    115 #> 5    225 #> 6    238 #> 7    113 #> 8    225 #> 9    238 #> 10   223 #> 11   227 #> 12   225 #> 13  <NA> #> 14  <NA> #> 15   222 #>"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_tokens.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","title":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","text":"Match sets hierarchical values (e.g. province / county / township) raw, messy dataset corresponding values within reference dataset, using tokenization help match multi-term values might otherwise difficult match (e.g. \"New York City\" vs. \"New York\"). Includes options ignoring matches frequently-occurring tokens (e.g. \"North\", \"South\", \"City\"), small tokens (e.g. \"El\", \"San\", \"New\"), set tokens specified user.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_tokens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","text":"","code":"hmatch_tokens(   raw,   ref,   pattern,   pattern_ref = pattern,   by,   by_ref = by,   type = \"left\",   allow_gaps = TRUE,   always_tokenize = FALSE,   token_split = \"_\",   token_min = 1,   exclude_freq = 3,   exclude_nchar = 3,   exclude_values = NULL,   fuzzy = FALSE,   fuzzy_method = \"osa\",   fuzzy_dist = 1L,   dict = NULL,   ref_prefix = \"ref_\",   std_fn = string_std,   ... )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_tokens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","text":"raw data frame containing hierarchical columns raw data ref data frame containing hierarchical columns reference data pattern regex pattern match hierarchical columns raw Note: hierarchical column names can matched using either pattern arguments. , neither pattern specified, hierarchical columns assumed column names common raw ref. See specifying_columns. pattern_ref regex pattern match hierarchical columns ref. Defaults pattern, need specify hierarchical columns different names raw ref. vector giving names hierarchical columns raw by_ref vector giving names hierarchical columns ref. Defaults , need specify hierarchical columns different names raw ref. type type join (\"left\", \"inner\", \"anti\", \"resolve_left\", \"resolve_inner\", \"resolve_anti\"). Defaults \"left\". See join_types. allow_gaps logical indicating whether allow missing values match level, 'match level' highest level non-missing value within given row raw. Defaults TRUE. always_tokenize logical indicating whether tokenize values prior matching (TRUE), first attempt non-tokenized matching hmatch tokenize values within raw (corresponding putative matches within ref) non-tokenized match (FALSE). Defaults FALSE. token_split regex pattern split strings tokens. Currently tokenization implemented string-standardizatipn argument std_fn (may change future version), regex pattern split standardized strings rather original strings. Defaults \"_\". token_min minimum number tokens must match term considered matching overall. Defaults 1. exclude_freq exclude tokens matching frequency greater equal value. Refers number unique, string-standardized values given hierarchical level given token occurs, calculated count_tokens (separately raw ref). Defaults 3. exclude_nchar exclude tokens matching nchar less equal value. Defaults 3. exclude_values character vector additional tokens exclude matching. Subject string-standardizatipn argument std_fn. fuzzy logical indicating whether use fuzzy-matching (based stringdist package). Defaults FALSE. fuzzy_method fuzzy = TRUE, method use string distance calculation (see stringdist-metrics). Defaults \"osa\". fuzzy_dist fuzzy = TRUE, maximum string distance use classify matches (.e. string distance less equal fuzzy_dist considered matching). Defaults 1L. dict optional dictionary recoding values within hierarchical columns raw (see dictionary_recoding) ref_prefix prefix add names returned columns ref otherwise identical names within raw. Defaults \"ref_\". std_fn function standardize strings matching. Defaults string_std. Set NULL omit standardization. See also string_standardization. ... additional arguments passed std_fn()","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_tokens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","text":"data frame obtained matching hierarchical columns raw ref, using join type specified argument type (see join_types details)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_tokens.html","id":"resolve-joins","dir":"Reference","previous_headings":"","what":"Resolve joins","title":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","text":"Uses approach resolve joins hmatch.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/hmatch_tokens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical matching with tokenization of multi-term values — hmatch_tokens","text":"","code":"data(ne_raw) data(ne_ref)  # add tokens to some values within ref to illustrate tokenized matching ne_ref$adm0[ne_ref$adm0 == \"United States\"] <- \"United States of America\" ne_ref$adm1[ne_ref$adm1 == \"New York\"] <- \"New York State\"  hmatch_tokens(ne_raw, ne_ref, type = \"inner\", token_min = 1) #>       id adm0           adm1         adm2 level ref_adm0       ref_adm1 #> 1  PID01  USA       New York      Suffolk  adm2      USA New York State #> 2  PID02  can        ontario         <NA>  adm1      CAN        Ontario #> 3  PID03  USA       New York Kings County  adm2      USA New York State #> 4  PID04 <NA>           <NA> Philadelphia  adm2      USA   Pennsylvania #> 5  PID05  USA           <NA>         York  adm2      USA New York State #> 6  PID05  USA           <NA>         York  adm2      USA   Pennsylvania #> 7  PID06  USA      new. york    jefferson  adm2      USA New York State #> 8  PID07  CAN        Ontario    Peel R.M.  adm2      CAN        Ontario #> 9  PID10 <NA>           <NA> Bergen, N.J.  adm2      USA     New Jersey #> 10 PID14 <NA>           <NA>         york  adm2      CAN        Ontario #> 11 PID14 <NA>           <NA>         york  adm2      USA New York State #> 12 PID14 <NA>           <NA>         york  adm2      USA   Pennsylvania #> 13 PID15  USA New York State     New York  adm2      USA New York State #>        ref_adm2 hcode #> 1       Suffolk   227 #> 2          <NA>   110 #> 3         Kings   223 #> 4  Philadelphia   237 #> 5      New York   225 #> 6          York   238 #> 7     Jefferson   222 #> 8          Peel   113 #> 9        Bergen   211 #> 10         York   115 #> 11     New York   225 #> 12         York   238 #> 13     New York   225"},{"path":"https://epicentre-msf.github.io/hmatch/reference/join_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Types of hierarchical joins — join_types","title":"Types of hierarchical joins — join_types","text":"basic join types used hmatch package (\"left\", \"inner\", \"anti\") conceptually equivalent dplyr's join types. three join types also counterpart prefixed \"resolve_\" (\"resolve_left\", \"resolve_inner\", \"resolve_anti\"). resolve join rows raw matches multiple rows ref resolved either single best match match subsequent join type implemented. resolve join, rows raw never duplicated. exact details match resolution vary somewhat among functions, explained within function's documentation.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/join_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Types of hierarchical joins — join_types","text":"left return rows raw, columns raw ref. Rows raw match ref NA values new columns taken ref. multiple matches raw ref, combinations matches returned. inner return rows raw matches ref, columns raw ref. multiple matches raw ref, combinations matches returned. anti return rows raw matches ref, keeping just columns raw resolve_left similar \"left\", except row raw initially multiple matches ref resolved either single 'best' match match. rows raw returned, rows raw never duplicated. resolve_inner similar \"inner\", except row raw initially multiple matches ref resolved either single 'best' match match. rows raw can resolved single best match returned, rows raw never duplicated. resolve_anti similar \"anti\", except row raw initially multiple matches ref considered non-matching (along rows raw initially matches ref), returned single row. Rows raw never duplicated.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/max_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum hierarchical levels — max_levels","title":"Maximum hierarchical levels — max_levels","text":"Given data frame columns specifying hierarchically-nested levels, find maximum non-missing hierarchical level row.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/max_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum hierarchical levels — max_levels","text":"","code":"max_levels(x, pattern, by, type = c(\"index\", \"name\"))"},{"path":"https://epicentre-msf.github.io/hmatch/reference/max_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum hierarchical levels — max_levels","text":"x data frame containing hierarchical columns pattern regex pattern match names hierarchical columns ref (supply either pattern ) vector giving names hierarchical columns ref (supply either pattern ) type type return, either \"index\" return integer indices (starting 1) \"name\" return column names (matched pattern )","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/max_levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum hierarchical levels — max_levels","text":"Vector indices names corresponding maximum non-missing hierarchical level row","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/max_levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum hierarchical levels — max_levels","text":"","code":"data(ne_ref)  # return integer indices (starting at 1) max_levels(ne_raw, pattern = \"^adm\") #>  [1] 3 2 3 3 3 3 3 3 3 3 2 2 3 3 3  # return column names max_levels(ne_raw, pattern = \"^adm\", type = \"name\") #>  [1] \"adm2\" \"adm1\" \"adm2\" \"adm2\" \"adm2\" \"adm2\" \"adm2\" \"adm2\" \"adm2\" \"adm2\" #> [11] \"adm1\" \"adm1\" \"adm2\" \"adm2\" \"adm2\""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ne_raw.html","id":null,"dir":"Reference","previous_headings":"","what":"Raw dataset — ne_raw","title":"Raw dataset — ne_raw","text":"Raw entries select administrative districts northeastern portion North America.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ne_raw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raw dataset — ne_raw","text":"","code":"ne_raw"},{"path":"https://epicentre-msf.github.io/hmatch/reference/ne_raw.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Raw dataset — ne_raw","text":"data.frame 15 rows 4 variables: id Identifier adm0 Name administrative 0 level (country) adm1 Name administrative 1 level (state/province) adm2 Name administrative 2 level (county/census division)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ne_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference dataset — ne_ref","title":"Reference dataset — ne_ref","text":"Reference table select administrative districts northeastern portion North America.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ne_ref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reference dataset — ne_ref","text":"","code":"ne_ref"},{"path":"https://epicentre-msf.github.io/hmatch/reference/ne_ref.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reference dataset — ne_ref","text":"data.frame 31 rows 4 variables, class character: level Administrative level adm0 Name administrative 0 level (country) adm1 Name administrative 1 level (state/province) adm2 Name administrative 2 level (county/census division) hcode Hierarchical code","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ref_expand.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand a reference data.frame containing N hierarchical columns to an N-level\nreference data.frame — ref_expand","title":"Expand a reference data.frame containing N hierarchical columns to an N-level\nreference data.frame — ref_expand","text":"example, municipality-level reference data.frame might contain three hierarchical columns — country, state, municipality — nonetheless reflect municipality level rows represent unique municipality. lower-resolution levels (state, country) implied explicitly represented unique rows. wish allow matches lower-resolution levels, need additional rows specific levels. function takes reference data.frame N hierarchical columns, adds rows unique combination level currently explicitly represented.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ref_expand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand a reference data.frame containing N hierarchical columns to an N-level\nreference data.frame — ref_expand","text":"","code":"ref_expand(ref, pattern, by, lowest_level = 1L)"},{"path":"https://epicentre-msf.github.io/hmatch/reference/ref_expand.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand a reference data.frame containing N hierarchical columns to an N-level\nreference data.frame — ref_expand","text":"ref data.frame containing hierarchical columns reference data pattern regex pattern match names hierarchical columns ref (supply either pattern ) vector giving names hierarchical columns ref (supply either pattern ) lowest_level integer representing lowest-resolution level (defaults 1)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ref_expand.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand a reference data.frame containing N hierarchical columns to an N-level\nreference data.frame — ref_expand","text":"data.frame created expanding ref implied hierarchical levels","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/ref_expand.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand a reference data.frame containing N hierarchical columns to an N-level\nreference data.frame — ref_expand","text":"","code":"# subset example reference df to the admin-2 level ne_ref_adm2 <- ne_ref[!is.na(ne_ref$adm2),]  # expand back to all levels ref_expand(ne_ref_adm2, pattern = \"adm\", lowest_level = 0) #>    level adm0         adm1         adm2 #> 1      0  CAN         <NA>         <NA> #> 2      0  USA         <NA>         <NA> #> 3      1  CAN      Ontario         <NA> #> 4      1  USA   New Jersey         <NA> #> 5      1  USA     New York         <NA> #> 6      1  USA Pennsylvania         <NA> #> 7      2  CAN      Ontario       Durham #> 8      2  CAN      Ontario       Halton #> 9      2  CAN      Ontario         Peel #> 10     2  CAN      Ontario      Toronto #> 11     2  CAN      Ontario         York #> 12     2  USA   New Jersey       Bergen #> 13     2  USA   New Jersey        Essex #> 14     2  USA   New Jersey       Hudson #> 15     2  USA   New Jersey    Middlesex #> 16     2  USA   New Jersey     Monmouth #> 17     2  USA     New York    Jefferson #> 18     2  USA     New York        Bronx #> 19     2  USA     New York        Kings #> 20     2  USA     New York       Nassau #> 21     2  USA     New York     New York #> 22     2  USA     New York       Queens #> 23     2  USA     New York      Suffolk #> 24     2  USA Pennsylvania    Allegheny #> 25     2  USA Pennsylvania        Bucks #> 26     2  USA Pennsylvania      Chester #> 27     2  USA Pennsylvania     Delaware #> 28     2  USA Pennsylvania    Jefferson #> 29     2  USA Pennsylvania    Lancaster #> 30     2  USA Pennsylvania Philadelphia #> 31     2  USA Pennsylvania         York"},{"path":"https://epicentre-msf.github.io/hmatch/reference/separate_hcode.html","id":null,"dir":"Reference","previous_headings":"","what":"Separate a hierarchical code reflecting multiple levels into its constituent\nparts, with one column for each level — separate_hcode","title":"Separate a hierarchical code reflecting multiple levels into its constituent\nparts, with one column for each level — separate_hcode","text":"Separate data frame column containing hierarchical codes multiple columns, one level within hierarchical code. Like tidyr::separate except successive levels cumulative rather independent. E.g. code \"canada__ontario__toronto\" split three levels: \"canada\" \"canada__ontario\" \"canada__ontario__toronto\"","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/separate_hcode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Separate a hierarchical code reflecting multiple levels into its constituent\nparts, with one column for each level — separate_hcode","text":"","code":"separate_hcode(   x,   col,   into,   sep = \"__\",   extra = c(\"warn\", \"drop\"),   remove = FALSE )"},{"path":"https://epicentre-msf.github.io/hmatch/reference/separate_hcode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Separate a hierarchical code reflecting multiple levels into its constituent\nparts, with one column for each level — separate_hcode","text":"x data.frame containing column hierarchical codes col Name column within x containing hierarchical codes. Vector column names separate col sep Separator levels hierarchical codes. Defaults \"__\". extra hierarchical code contains levels implied argument . \"warn\" (default): emit warning drop extra values \"drop\": drop extra values without warning remove Logical indicating whether remove col output. Defaults FALSE.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/separate_hcode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Separate a hierarchical code reflecting multiple levels into its constituent\nparts, with one column for each level — separate_hcode","text":"original data.frame x additional columns level hierarchical code","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/separate_hcode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Separate a hierarchical code reflecting multiple levels into its constituent\nparts, with one column for each level — separate_hcode","text":"","code":"data(ne_ref)  # generate pcode ne_ref$pcode <- hcodes_str(ne_ref, pattern = \"^adm\\\\d\")  # separate pcode into constituent levels separate_hcode(   ne_ref,   col = \"pcode\",   into = c(\"adm0_pcode\", \"adm1_pcode\", \"adm2_pcode\") ) #>    level adm0         adm1         adm2 hcode                           pcode #> 1   adm0  CAN         <NA>         <NA>   100                             can #> 2   adm0  USA         <NA>         <NA>   200                             usa #> 3   adm1  CAN      Ontario         <NA>   110                    can__ontario #> 4   adm1  USA   New Jersey         <NA>   210                 usa__new_jersey #> 5   adm1  USA     New York         <NA>   220                   usa__new_york #> 6   adm1  USA Pennsylvania         <NA>   230               usa__pennsylvania #> 7   adm2  CAN      Ontario       Durham   111            can__ontario__durham #> 8   adm2  CAN      Ontario       Halton   112            can__ontario__halton #> 9   adm2  CAN      Ontario         Peel   113              can__ontario__peel #> 10  adm2  CAN      Ontario      Toronto   114           can__ontario__toronto #> 11  adm2  CAN      Ontario         York   115              can__ontario__york #> 12  adm2  USA   New Jersey       Bergen   211         usa__new_jersey__bergen #> 13  adm2  USA   New Jersey        Essex   212          usa__new_jersey__essex #> 14  adm2  USA   New Jersey       Hudson   213         usa__new_jersey__hudson #> 15  adm2  USA   New Jersey    Middlesex   214      usa__new_jersey__middlesex #> 16  adm2  USA   New Jersey     Monmouth   215       usa__new_jersey__monmouth #> 17  adm2  USA     New York    Jefferson   222        usa__new_york__jefferson #> 18  adm2  USA     New York        Bronx   221            usa__new_york__bronx #> 19  adm2  USA     New York        Kings   223            usa__new_york__kings #> 20  adm2  USA     New York       Nassau   224           usa__new_york__nassau #> 21  adm2  USA     New York     New York   225         usa__new_york__new_york #> 22  adm2  USA     New York       Queens   226           usa__new_york__queens #> 23  adm2  USA     New York      Suffolk   227          usa__new_york__suffolk #> 24  adm2  USA Pennsylvania    Allegheny   231    usa__pennsylvania__allegheny #> 25  adm2  USA Pennsylvania        Bucks   232        usa__pennsylvania__bucks #> 26  adm2  USA Pennsylvania      Chester   233      usa__pennsylvania__chester #> 27  adm2  USA Pennsylvania     Delaware   234     usa__pennsylvania__delaware #> 28  adm2  USA Pennsylvania    Jefferson   235    usa__pennsylvania__jefferson #> 29  adm2  USA Pennsylvania    Lancaster   236    usa__pennsylvania__lancaster #> 30  adm2  USA Pennsylvania Philadelphia   237 usa__pennsylvania__philadelphia #> 31  adm2  USA Pennsylvania         York   238         usa__pennsylvania__york #>    adm0_pcode        adm1_pcode                      adm2_pcode #> 1         can              <NA>                            <NA> #> 2         usa              <NA>                            <NA> #> 3         can      can__ontario                            <NA> #> 4         usa   usa__new_jersey                            <NA> #> 5         usa     usa__new_york                            <NA> #> 6         usa usa__pennsylvania                            <NA> #> 7         can      can__ontario            can__ontario__durham #> 8         can      can__ontario            can__ontario__halton #> 9         can      can__ontario              can__ontario__peel #> 10        can      can__ontario           can__ontario__toronto #> 11        can      can__ontario              can__ontario__york #> 12        usa   usa__new_jersey         usa__new_jersey__bergen #> 13        usa   usa__new_jersey          usa__new_jersey__essex #> 14        usa   usa__new_jersey         usa__new_jersey__hudson #> 15        usa   usa__new_jersey      usa__new_jersey__middlesex #> 16        usa   usa__new_jersey       usa__new_jersey__monmouth #> 17        usa     usa__new_york        usa__new_york__jefferson #> 18        usa     usa__new_york            usa__new_york__bronx #> 19        usa     usa__new_york            usa__new_york__kings #> 20        usa     usa__new_york           usa__new_york__nassau #> 21        usa     usa__new_york         usa__new_york__new_york #> 22        usa     usa__new_york           usa__new_york__queens #> 23        usa     usa__new_york          usa__new_york__suffolk #> 24        usa usa__pennsylvania    usa__pennsylvania__allegheny #> 25        usa usa__pennsylvania        usa__pennsylvania__bucks #> 26        usa usa__pennsylvania      usa__pennsylvania__chester #> 27        usa usa__pennsylvania     usa__pennsylvania__delaware #> 28        usa usa__pennsylvania    usa__pennsylvania__jefferson #> 29        usa usa__pennsylvania    usa__pennsylvania__lancaster #> 30        usa usa__pennsylvania usa__pennsylvania__philadelphia #> 31        usa usa__pennsylvania         usa__pennsylvania__york"},{"path":"https://epicentre-msf.github.io/hmatch/reference/specifying_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Specifying hierarchical columns with arguments pattern or by — specifying_columns","title":"Specifying hierarchical columns with arguments pattern or by — specifying_columns","text":"Within hmatch_ group functions, three ways specify hierarchical columns matched. cases, assumed matched columns already correctly ordered, first matched column reflecting broadest hierarchical level (lowest-resolution, e.g. country) last column reflecting finest level (highest-resolution, e.g. township).","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/specifying_columns.html","id":"-all-column-names-common-to-raw-and-ref","dir":"Reference","previous_headings":"","what":"(1) All column names common to raw and ref","title":"Specifying hierarchical columns with arguments pattern or by — specifying_columns","text":"neither pattern specified (default), hierarchical columns assumed column names common raw ref.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/specifying_columns.html","id":"-regex-pattern","dir":"Reference","previous_headings":"","what":"(2) Regex pattern","title":"Specifying hierarchical columns with arguments pattern or by — specifying_columns","text":"Arguments pattern pattern_ref take regex patterns match hierarchical columns raw ref, respectively. Argument pattern_ref needs specified different pattern (.e. hierarchical columns different names raw vs. ref). example, hierarchical columns raw \"ADM_1\", \"ADM_2\", \"ADM_3\", correspond respectively columns within ref named \"REF_ADM_1\", \"REF_ADM_2\", \"REF_ADM_3\", pattern arguments can specified : pattern = \"^ADM_[[:digit:]]\" pattern_ref = \"^REF_ADM_[[:digit:]]\" Alternatively, pattern_ref defaults value pattern (unless otherwise specified), one specify single regex pattern matches hierarchical columns raw ref, e.g. pattern = \"ADM_[[:digit:]]\" However, user exercise care ensure non-hierarchical columns within raw ref may inadvertently matched given pattern.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/specifying_columns.html","id":"-vector-of-column-names","dir":"Reference","previous_headings":"","what":"(3) Vector of column names","title":"Specifying hierarchical columns with arguments pattern or by — specifying_columns","text":"hierarchical columns easily matched regex pattern, one can specify relevant column names vector form using arguments by_ref. pattern_ref, argument by_ref needs specified different (.e. hierarchical columns different names raw vs. ref). example, hierarchical columns raw \"state\", \"county\", \"township\", correspond respectively columns within ref named \"admin1\", \"admin2\", \"admin3\", theby arguments can specified : = c(\"state\", \"county\", \"township\") by_ref = c(\"admin1\", \"admin2\", \"admin3\")","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/string_standardization.html","id":null,"dir":"Reference","previous_headings":"","what":"String Standardization — string_standardization","title":"String Standardization — string_standardization","text":"Prior matching raw reference datasets, one might wish standardize strings within match columns account differences case, punctuation, etc. default, standardization performed function string_std, implements four transformations: standardize case (base::tolower) remove sequences non-alphanumeric characters start end string replace remaining sequences non-alphanumeric characters \"_\" remove diacritics (stringi::stri_trans_general) (optional) convert roman numerals (, II, ..., XLIX) arabic (1, 2, ..., 49) Alternatively, user may provide function takes vector strings returns vector transformed strings. omit transformation, set argument std_fn = NULL. Note standardized versions match columns never returned. used matching, removed prior return.","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/string_std.html","id":null,"dir":"Reference","previous_headings":"","what":"String standardization prior to matching — string_std","title":"String standardization prior to matching — string_std","text":"Standardizes strings prior performing match, using following transformations: standardize case (base::tolower) remove sequences non-alphanumeric characters start end string replace remaining sequences non-alphanumeric characters \"_\" remove diacritics (stringi::stri_trans_general) (optional) convert roman numerals (, II, ..., XLIX) arabic (1, 2, ..., 49)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/string_std.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"String standardization prior to matching — string_std","text":"","code":"string_std(x, convert_roman = FALSE)"},{"path":"https://epicentre-msf.github.io/hmatch/reference/string_std.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"String standardization prior to matching — string_std","text":"x string convert_roman logical indiciating whether convert roman numerals (, II, ..., XLIX) arabic (1, 2, ..., 49)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/reference/string_std.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"String standardization prior to matching — string_std","text":"standardized version x","code":""},{"path":[]},{"path":"https://epicentre-msf.github.io/hmatch/reference/string_std.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"String standardization prior to matching — string_std","text":"","code":"string_std(\"United STATES\") #> [1] \"united_states\" string_std(\"R\\u00e9publique  d\\u00e9mocratique du  Congo\") #> [1] \"republique_democratique_du_congo\"  # convert roman numerals to arabic string_std(\"Mungindu-II (Sud)\") #> [1] \"mungindu_ii_sud\" string_std(\"Mungindu-II (Sud)\", convert_roman = TRUE) #> [1] \"mungindu_2_sud\"  # note the conversion only works if the numeral is separated from other # alphanumeric characters by punctuation or space characters string_std(\"MunginduII\", convert_roman = TRUE) # roman numeral not recognized #> [1] \"munginduii\""},{"path":"https://epicentre-msf.github.io/hmatch/news/index.html","id":"hmatch-0109000","dir":"Changelog","previous_headings":"","what":"hmatch 0.1.0.9000","title":"hmatch 0.1.0.9000","text":"New function separate_hcode() separate column containing hierarchical codes (e.g. “pcode”) multiple columns, one hierarchical level (e.g. “pcode_adm1”, “pcode_adm2”, etc.)","code":""},{"path":"https://epicentre-msf.github.io/hmatch/news/index.html","id":"hmatch-010","dir":"Changelog","previous_headings":"","what":"hmatch 0.1.0","title":"hmatch 0.1.0","text":"Initial release","code":""}]
