% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmatch_best.R
\name{hmatch_settle}
\alias{hmatch_settle}
\title{Sequential hierarchical matching at each hierarchical level, settling for the
highest resolution match that is possible for each row}
\usage{
hmatch_settle(
  raw,
  ref,
  pattern,
  pattern_ref = pattern,
  by,
  by_ref = by,
  type = "left",
  allow_gaps = TRUE,
  fuzzy = FALSE,
  fuzzy_method = "osa",
  fuzzy_dist = 1L,
  dict = NULL,
  ref_prefix = "ref_",
  std_fn = string_std,
  ...
)
}
\arguments{
\item{raw}{data frame containing hierarchical columns with raw data}

\item{ref}{data frame containing hierarchical columns with reference data}

\item{pattern}{regex pattern to match the hierarchical columns in \code{raw}\cr

\strong{Note:} hierarchical column names can be matched using either the \code{pattern}
\emph{or} \code{by} arguments. Or, if neither \code{pattern} or \code{by} are specified, the
hierarchical columns are assumed to be all column names that are common to
both \code{raw} and \code{ref}. See \link{specifying_columns}.}

\item{pattern_ref}{regex pattern to match the hierarchical columns in \code{ref}.
Defaults to \code{pattern}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{by}{vector giving the names of the hierarchical columns in \code{raw}}

\item{by_ref}{vector giving the names of the hierarchical columns in \code{ref}.
Defaults to \code{by}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{type}{type of join ("left", "inner", "anti", "resolve_left",
"resolve_inner", or "resolve_anti"). Defaults to "left". See
\link{join_types}.}

\item{allow_gaps}{logical indicating whether to allow missing values below
the match level, where 'match level' is the highest level with a
non-missing value within a given row of \code{raw}. Defaults to \code{TRUE}.}

\item{fuzzy}{logical indicating whether to use fuzzy-matching (based on the
\code{\link{stringdist}} package). Defaults to FALSE.}

\item{fuzzy_method}{if \code{fuzzy = TRUE}, the method to use for string distance
calculation (see \link[stringdist]{stringdist-metrics}). Defaults to "osa".}

\item{fuzzy_dist}{if \code{fuzzy = TRUE}, the maximum string distance to use to
classify matches (i.e. a string distance â‰¤ \code{fuzzy_dist} will be considered
matching). Defaults to \code{1L}.}

\item{dict}{optional dictionary for recoding values within the hierarchical
columns of \code{raw} (see \link{dictionary_recoding})}

\item{ref_prefix}{prefix to add to names of returned columns from \code{ref} if
they are otherwise identical to names within \code{raw}. Defaults to "ref_".}

\item{std_fn}{function to standardize strings during matching. Defaults to
\code{\link{string_std}}. Set to \code{NULL} to omit standardization. See
also \link{string_standardization}.}

\item{...}{additional arguments passed to \code{std_fn()}}
}
\value{
a data frame obtained by matching the hierarchical columns in \code{raw}
and \code{ref}, using the join type specified by argument \code{type} (see
\link{join_types} for more details)
}
\description{
Match sets of hierarchical values (e.g. province / county / township) in a
raw, messy dataset to corresponding values within a reference dataset,
sequentially over each hierarchical level. Specifically, implements
\code{\link{hmatch}} at each successive hierarchical level, starting with
only the first level (lowest resolution), then first and second, first second
and third, etc.

After the initial matching over all levels, users can optionally use a
resolve join to 'settle' for the highest match possible for each row of raw
data, even if that match is below the highest-resolution level specified.
}
\section{Resolve joins}{

In a resolve type join with \code{hmatch_settle}, rows of \code{raw} with multiple
matches to \code{ref} are resolved to the highest hierarchical level that is
non-conflicting among all matches (or no match if there is a conflict at the
very first level). E.g.

\code{raw}: \cr
\verb{1. | United States | <NA>         | Jefferson |} \cr

Relevant rows from \code{ref}: \cr
\verb{1. | United States | <NA>         | <NA>      |} \cr
\verb{2. | United States | New York     | Jefferson |} \cr
\verb{3. | United States | Pennsylvania | Jefferson |}

In a regular join, the single row from \code{raw} (above) will match all three
rows from \code{ref}. However, in a resolve join the multiple matches will be
resolved to the first row from \code{ref}, because only the first hierarchical
level ("United States") is non-conflicting among all possible matches.

Note that there's a distinction between "common" values at a given
hierarchical level (i.e. a single unique value in each row) and
"non-conflicting" values (i.e. a single unique value \emph{or} a missing value).
E.g.

\code{raw}: \cr
\verb{1. | United States | New York | New York |} \cr

Relevant rows from \code{ref}: \cr
\verb{1. | United States | <NA>     | <NA>     |} \cr
\verb{2. | United States | New York | <NA>     |} \cr
\verb{3. | United States | New York | New York |}

In the example above, only the 1st hierarchical level ("United States") is
"common" to all matches, but all hierarchical levels are "non-conflicting"
(i.e. because row 2 is a hierarchical child of row 1, and row 3 a child of
row 2), and so a resolve-type match will be made to the 3rd row in \code{ref}.
}

\examples{
data(ne_raw)
data(ne_ref)

# return matches at all levels
hmatch_settle(ne_raw, ne_ref, pattern = "^adm", type = "inner")

# use a resolve join to settle for the best possible match for each row
hmatch_settle(ne_raw, ne_ref, pattern = "^adm", type = "resolve_inner")

}
