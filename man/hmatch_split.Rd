% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmatch_split.R
\name{hmatch_split}
\alias{hmatch_split}
\title{Hierarchical matching, separately at each hierarchical level}
\usage{
hmatch_split(
  raw,
  ref,
  pattern,
  pattern_ref = pattern,
  by,
  by_ref = by,
  fn = "hmatch",
  type = "left",
  allow_gaps = TRUE,
  fuzzy = FALSE,
  fuzzy_method = "osa",
  fuzzy_dist = 1L,
  dict = NULL,
  ref_prefix = "ref_",
  std_fn = string_std,
  ...,
  levels = NULL,
  always_list = FALSE,
  man,
  code_col,
  always_tokenize = FALSE,
  token_split = "_",
  exclude_freq = 3,
  exclude_nchar = 3,
  exclude_values = NULL
)
}
\arguments{
\item{raw}{data frame containing hierarchical columns with raw data}

\item{ref}{data frame containing hierarchical columns with reference data}

\item{pattern}{regex pattern to match the hierarchical columns in \code{raw}\cr

\strong{Note:} hierarchical column names can be matched using either the \code{pattern}
\emph{or} \code{by} arguments. Or, if neither \code{pattern} or \code{by} are specified, the
hierarchical columns are assumed to be all column names that are common to
both \code{raw} and \code{ref}. See \link{specifying_columns}.}

\item{pattern_ref}{regex pattern to match the hierarchical columns in \code{ref}.
Defaults to \code{pattern}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{by}{vector giving the names of the hierarchical columns in \code{raw}}

\item{by_ref}{vector giving the names of the hierarchical columns in \code{ref}.
Defaults to \code{by}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{fn}{which function to use for matching. Current options are
\code{\link{hmatch}}, \code{\link{hmatch_permute}},
\code{\link{hmatch_tokens}}, \code{\link{hmatch_best}}, or
\code{\link{hmatch_composite}}. Defaults to "hmatch".

Note that some subsequent arguments are only relevant for specific
functions (e.g. the \code{exclude_} arguments are only relevant if \code{fn = "hmatch_tokens"}).}

\item{type}{type of join ("left", "inner", "anti", "resolve_left",
"resolve_inner", or "resolve_anti"). Defaults to "left". See
\link{join_types}.

Note that the details of resolve joins vary somewhat among hmatch functions
(see documentation for the relevant function), and that function
\code{\link{hmatch_composite}} only allows resolve joins.}

\item{allow_gaps}{logical indicating whether to allow missing values below
the match level, where 'match level' is the highest level with a
non-missing value within a given row of \code{raw}. Defaults to \code{TRUE}.}

\item{fuzzy}{logical indicating whether to use fuzzy-matching (based on the
\code{\link{stringdist}} package). Defaults to FALSE.}

\item{fuzzy_method}{if \code{fuzzy = TRUE}, the method to use for string distance
calculation (see \link[stringdist]{stringdist-metrics}). Defaults to "osa".}

\item{fuzzy_dist}{if \code{fuzzy = TRUE}, the maximum string distance to use to
classify matches (i.e. a string distance â‰¤ \code{fuzzy_dist} will be considered
matching). Defaults to \code{1L}.}

\item{dict}{optional dictionary for recoding values within the hierarchical
columns of \code{raw} (see \link{dictionary_recoding})}

\item{ref_prefix}{prefix to add to names of returned columns from \code{ref} if
they are otherwise identical to names within \code{raw}. Defaults to "ref_".}

\item{std_fn}{function to standardize strings during matching. Defaults to
\code{\link{string_std}}. Set to \code{NULL} to omit standardization. See
also \link{string_standardization}.}

\item{...}{additional arguments passed to \code{std_fn()}}

\item{levels}{a vector of names or integer indices corresponding to one or
more of the hierarchical columns in \code{raw} to match at. Defaults to \code{NULL}
in which case matches are made at each hierarchical level.}

\item{always_list}{logical indicating whether to always return a list, even
when argument \code{levels} specifies a single match level. Defaults to \code{FALSE}.}

\item{man}{(optional) data frame of manually-specified matches, relating a
given set of hierarchical values to the code within \code{ref} to which those
values correspond}

\item{code_col}{name of the code column containing codes for matching \code{ref}
and \code{man} (only required if argument \code{man} is given)}

\item{always_tokenize}{logical indicating whether to tokenize all values
prior to matching (\code{TRUE}), or to first attempt non-tokenized matching with
\code{\link{hmatch}} and only tokenize values within \code{raw} (and
corresponding putative matches within \code{ref}) that don't have a
non-tokenized match (\code{FALSE}). Defaults to \code{FALSE}.}

\item{token_split}{regex pattern to split strings into tokens. Currently
tokenization is implemented \emph{after}
\link[=string_standardization]{string-standardizatipn} with argument
\code{std_fn} (this may change in a future version), so the regex pattern should
split \emph{standardized} strings rather than the original strings. Defaults to
"_".}

\item{exclude_freq}{exclude tokens from matching if they have a frequency
greater than or equal to this value. Refers to the number of unique,
string-standardized values at a given hierarchical level in which a given
token occurs, as calculated by \code{\link{count_tokens}} (separately for
\code{raw} and \code{ref}). Defaults to \code{3}.}

\item{exclude_nchar}{exclude tokens from matching if they have \link{nchar}
less than or equal to this value. Defaults to \code{3}.}

\item{exclude_values}{character vector of additional tokens to exclude from
matching. Subject to \link[=string_standardization]{string-standardizatipn}
with argument \code{std_fn}.}
}
\value{
A list of data frames, each returned by a call to \code{fn} on the unique
combination of hierarchical values at the given hierarchical level. The
number of elements in the list corresponds to the number of hierarchical
columns in \code{raw}, or, if specified, the number of elements in argument
\code{levels}.

However, if \code{always_list = FALSE} and \code{length(levels) == 1}, a single data
frame is returned (i.e. not wrapped in a list).
}
\description{
Implements hierarchical matching, separately at each hierarchical level
within the data. For a given level, the raw data that is matched includes
every unique combination of values at and below the level of interest. E.g.

Level 1: \cr
\verb{| Canada        |} \cr
\verb{| United States |} \cr

Level 2: \cr
\verb{| Canada        | Ontario      |} \cr
\verb{| United States | New York     |} \cr
\verb{| United States | Pennsylvania |} \cr

Level 3: \cr
\verb{| Canada        | Ontario      | Ottawa       |} \cr
\verb{| Canada        | Ontario      | Toronto      |} \cr
\verb{| United States | New York     | Bronx        |} \cr
\verb{| United States | New York     | New York     |} \cr
\verb{| United States | Pennsylvania | Philadelphia |}
}
\examples{
data(ne_raw)
data(ne_ref)

# by default calls fn `hmatch` separately for each hierarchical level
hmatch_split(ne_raw, ne_ref)

# can also specify other hmatch functions, and subsets of hierarchical levels
hmatch_split(ne_raw, ne_ref, fn = "hmatch_tokens", levels = 2:3)

}
