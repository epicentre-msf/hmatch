% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmatch.R
\name{hmatch}
\alias{hmatch}
\title{Match sets of hierarchical variables between a raw and reference dataset}
\usage{
hmatch(
  raw,
  ref,
  pattern = NULL,
  pattern_ref = pattern,
  by = NULL,
  by_ref = by,
  type = "left",
  allow_gaps = TRUE,
  fuzzy = FALSE,
  fuzzy_method = "osa",
  fuzzy_dist = 1L,
  dict = NULL,
  ref_prefix = "ref_",
  std_fn = string_std,
  ...
)
}
\arguments{
\item{raw}{data frame containing hierarchical columns with raw data}

\item{ref}{data frame containing hierarchical columns with reference data}

\item{pattern}{regex pattern to match the hierarchical columns in \code{raw}
(columns can be matched using either \code{pattern} \emph{or} \code{by}, as described in
\link{specifying_columns})}

\item{pattern_ref}{regex pattern to match the hierarchical columns in \code{ref}
(defaults to \code{pattern})}

\item{by}{vector giving the names of the hierarchical columns in \code{raw}}

\item{by_ref}{vector giving the names of the hierarchical columns in \code{ref}
(defaults to \code{by})}

\item{type}{type of join ("left", "inner", "anti", "resolve_left",
"resolve_inner", or "resolve_anti"). Defaults to "left". See
\link{join_types}.}

\item{allow_gaps}{logical indicating whether to allow missing values below
the 'match level', defined as the highest level with a non-missing value
within a given row of \code{raw} (defaults to \code{TRUE})}

\item{fuzzy}{logical indicating whether to use fuzzy-matching (based on the
\code{\link{stringdist}} package). Defaults to FALSE.}

\item{fuzzy_method}{if \code{fuzzy = TRUE}, the method to use for string distance
calculation (see \link[stringdist]{stringdist-metrics}). Defaults to "osa".}

\item{fuzzy_dist}{if \code{fuzzy = TRUE}, the maximum string distance to use to
classify matches (i.e. a string distance â‰¤ \code{fuzzy_dist} will be considered
matching). Defaults to \code{1L}.}

\item{dict}{optional dictionary for recoding values within the hierarchical
columns of \code{raw} (see \link{dictionary_recoding})}

\item{ref_prefix}{prefix to add to hierarchical column names in \code{ref} if they
are otherwise identical to names in \code{raw}  (defaults to "ref_")}

\item{std_fn}{function to standardize strings during matching. Defaults to
\code{\link{string_std}}. Set to \code{NULL} to omit standardization. See
also \link{string_standardization}.}

\item{...}{additional arguments passed to \code{std_fn()}}
}
\value{
a data frame obtained by matching the hierarchical columns in \code{raw}
and \code{ref}, using the join type specified by argument \code{type} (see
\link{join_types} for more details)
}
\description{
Match sets of hierarchical values (e.g. province, county, township) in a raw,
messy dataset to corresponding values within a reference dataset, optionally
accounting for discrepancies between the datasets such as:
\itemize{
\item variation in character case, use of accents, or spelling
\item variation in hierarchical resolution (e.g. some entries specified to
municipality but others only to region)
\item missing values at one or more hierarchical levels
}
}
\section{Resolve joins}{

In \code{hmatch}, if argument \code{type} corresponds to a resolve join, rows
of \code{raw} with multiple matches to \code{ref} are always resolved to 'no match'.
This is because \code{hmatch} does not accept matches below the highest
non-missing level within a given row of \code{raw}. E.g.

\code{raw}: \cr
\verb{1. | United States | <NA>         | Jefferson |} \cr

Relevant rows from \code{ref}: \cr
\verb{1. | United States | New York     | Jefferson |} \cr
\verb{2. | United States | Pennsylvania | Jefferson |}

In a regular join with \code{hmatch}, the single row from \code{raw} (above)
will match both rows of \code{ref}. However, in a resolve join the multiple
conflicting matches (i.e. conflicting values at the 2nd hierarchical level)
will result in the row from \code{raw} being treated as non-matching to \code{ref}.
}

\examples{
data(ne_raw)
data(ne_ref)

hmatch(ne_raw, ne_ref, pattern = "adm", type = "inner")

# with dictionary-based recoding
ne_dict <- data.frame(value = "USA",
                      replacement = "United States",
                      variable = "adm0")

hmatch(ne_raw, ne_ref, pattern = "adm", dict = ne_dict)

}
