% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmatch_best.R
\name{hmatch_best}
\alias{hmatch_best}
\title{Best-possible hierarchical matching}
\usage{
hmatch_best(
  raw,
  ref,
  pattern,
  pattern_ref = pattern,
  by,
  by_ref = by,
  type = "left",
  allow_gaps = TRUE,
  fuzzy = FALSE,
  fuzzy_method = "osa",
  fuzzy_dist = 1L,
  dict = NULL,
  ref_prefix = "ref_",
  std_fn = string_std,
  ...
)
}
\arguments{
\item{raw}{data frame containing hierarchical columns with raw data}

\item{ref}{data frame containing hierarchical columns with reference data}

\item{pattern}{regex pattern to match the hierarchical columns in \code{raw}\cr

\strong{Note:} hierarchical column names can be matched using either the \code{pattern}
\emph{or} \code{by} arguments. Or, if neither \code{pattern} or \code{by} are specified, the
hierarchical columns are assumed to be all column names that are common to
both \code{raw} and \code{ref}. See \link{specifying_columns}.}

\item{pattern_ref}{regex pattern to match the hierarchical columns in \code{ref}.
Defaults to \code{pattern}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{by}{vector giving the names of the hierarchical columns in \code{raw}}

\item{by_ref}{vector giving the names of the hierarchical columns in \code{ref}.
Defaults to \code{by}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{type}{type of join ("left", "inner", "anti", "resolve_left",
"resolve_inner", or "resolve_anti"). Defaults to "left". See
\link{join_types}.}

\item{allow_gaps}{logical indicating whether to allow missing values below
the match level, where 'match level' is the highest level with a
non-missing value within a given row of \code{raw}. Defaults to \code{TRUE}.}

\item{fuzzy}{logical indicating whether to use fuzzy-matching (based on the
\code{\link{stringdist}} package). Defaults to FALSE.}

\item{fuzzy_method}{if \code{fuzzy = TRUE}, the method to use for string distance
calculation (see \link[stringdist]{stringdist-metrics}). Defaults to "osa".}

\item{fuzzy_dist}{if \code{fuzzy = TRUE}, the maximum string distance to use to
classify matches (i.e. a string distance â‰¤ \code{fuzzy_dist} will be considered
matching). Defaults to \code{1L}.}

\item{dict}{optional dictionary for recoding values within the hierarchical
columns of \code{raw} (see \link{dictionary_recoding})}

\item{ref_prefix}{prefix to add to names of returned columns from \code{ref} if
they are otherwise identical to names within \code{raw}. Defaults to "ref_".}

\item{std_fn}{function to standardize strings during matching. Defaults to
\code{\link{string_std}}. Set to \code{NULL} to omit standardization. See
also \link{string_standardization}.}

\item{...}{additional arguments passed to \code{std_fn()}}
}
\value{
a data frame obtained by matching the hierarchical columns in \code{raw}
and \code{ref}, using the join type specified by argument \code{type} (see
\link{join_types} for more details)
}
\description{
Match a data frame with raw, potentially messy hierarchical data (e.g.
province, county, township) against a reference dataset, using a rolling
approach to identify the best-possible (i.e. highest-resolution) match for
each row.

The rolling approach implements \code{\link{hmatch}} at each successive
level, starting with only the first level, then the first and second level,
etc. The 'best-possible' match reflects the highest-level that is consistent
among all possible matches to the given row of raw data.
}
\section{Resolve joins}{

In \code{hmatch_best}, if argument \code{type} corresponds to a resolve join, rows of
\code{raw} with multiple matches to \code{ref} are resolved to the highest hierarchical
level that is non-conflicting among all matches (or no match if there is a
conflict at the very first level). E.g.

\code{raw}: \cr
\verb{1. | United States | <NA>         | Jefferson |} \cr

Relevant rows from \code{ref}: \cr
\verb{1. | United States | <NA>         | <NA>      |} \cr
\verb{2. | United States | New York     | Jefferson |} \cr
\verb{3. | United States | Pennsylvania | Jefferson |}

In a regular join, the single row from \code{raw} (above) will match all three
rows from \code{ref}. However, in a resolve join the multiple matches will be
resolved to the first row from \code{ref}, because only the first hierarchical
level ("United States") is non-conflicting among all possible matches.

Note that there's a distinction between "common" values at a given
hierarchical level (i.e. a single unique value in each row) and
"non-conflicting" values (i.e. a single unique value \emph{or} a missing value).
E.g.

\code{raw}: \cr
\verb{1. | United States | New York | New York |} \cr

Relevant rows from \code{ref}: \cr
\verb{1. | United States | <NA>     | <NA>     |} \cr
\verb{2. | United States | New York | <NA>     |} \cr
\verb{3. | United States | New York | New York |}

In the example above, only the 1st hierarchical level ("United States") is
"common" to all matches, but all hierarchical levels are "non-conflicting"
(i.e. because row 2 is a hierarchical child of row 1, and row 3 a child of
row 2), and so a resolve-type match will be made to the 3rd row in \code{ref}.
}

\examples{
data(ne_raw)
data(ne_ref)

hmatch_best(ne_raw, ne_ref, pattern = "adm", fuzzy = TRUE, type = "inner")

# with dictionary-based recoding
ne_dict <- data.frame(value = "USA",
                      replacement = "United States",
                      variable = "adm0")

hmatch_best(ne_raw, ne_ref, dict = ne_dict, fuzzy = TRUE)

}
