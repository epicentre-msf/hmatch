% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spmatch_best.R
\name{spmatch_best}
\alias{spmatch_best}
\title{Best-possible hierarchical matching, separately at each hierarchical level}
\usage{
spmatch_best(
  raw,
  ref,
  pattern,
  pattern_ref = pattern,
  by,
  by_ref = by_ref,
  dict = NULL,
  type = "left",
  ref_prefix = "ref_",
  fuzzy = FALSE,
  fuzzy_method = "osa",
  fuzzy_dist = 1L,
  std_fn = string_std,
  ...,
  levels = NULL,
  always_list = FALSE
)
}
\arguments{
\item{raw}{data frame containing hierarchical columns with raw data}

\item{ref}{data frame containing hierarchical columns with reference data}

\item{pattern}{regex pattern to match the hierarchical columns in \code{raw}\cr

\strong{Note:} hierarchical column names can be matched using either the \code{pattern}
\emph{or} \code{by} arguments. Or, if neither \code{pattern} or \code{by} are specified, the
hierarchical columns are assumed to be all column names that are common to
both \code{raw} and \code{ref}. See \link{specifying_columns}.}

\item{pattern_ref}{regex pattern to match the hierarchical columns in \code{ref}.
Defaults to \code{pattern}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{by}{vector giving the names of the hierarchical columns in \code{raw}}

\item{by_ref}{vector giving the names of the hierarchical columns in \code{ref}.
Defaults to \code{by}, so only need to specify if the hierarchical columns
have different names in \code{raw} and \code{ref}.}

\item{dict}{optional dictionary for recoding values within the hierarchical
columns of \code{raw} (see \link{dictionary_recoding})}

\item{type}{type of join ("left", "inner", "anti", "resolve_left",
"resolve_inner", or "resolve_anti"). Defaults to "left". See
\link{join_types}.}

\item{ref_prefix}{prefix to add to returned hierarchical column names in
\code{ref} if they are otherwise identical to names in \code{raw}  (defaults to
"ref_")}

\item{fuzzy}{logical indicating whether to use fuzzy-matching (based on the
\code{\link{stringdist}} package). Defaults to FALSE.}

\item{fuzzy_method}{if \code{fuzzy = TRUE}, the method to use for string distance
calculation (see \link[stringdist]{stringdist-metrics}). Defaults to "osa".}

\item{fuzzy_dist}{if \code{fuzzy = TRUE}, the maximum string distance to use to
classify matches (i.e. a string distance â‰¤ \code{fuzzy_dist} will be considered
matching). Defaults to \code{1L}.}

\item{std_fn}{function to standardize strings during matching. Defaults to
\code{\link{string_std}}. Set to \code{NULL} to omit standardization. See
also \link{string_standardization}.}

\item{...}{additional arguments passed to \code{std_fn()}}

\item{levels}{a vector of names or integer indices corresponding to one or
more of the hierarchical columns in \code{raw} to match at. Defaults to \code{NULL}
in which case matches are made at each hierarchical level.}

\item{always_list}{logical indicating whether to always return a list, even
when argument \code{levels} specifies a single match level (defaults to \code{FALSE})}
}
\value{
A list of data frames, each returned by a call to \code{hmatch_best} on
the unique combination of hierarchical values at the given hierarchical
level. The number of elements in the list corresponds to the number of
hierarchical columns in \code{raw}, or, if specified, the number of elements in
argument \code{levels}.
}
\description{
Implements hierarchical matching with \code{\link{hmatch_best}}, separately
at each hierarchical level within the data. For a given level, the raw data
that is matched includes every unique combination of values at and below the
level of interest. E.g.

L1: Canada \cr L1: United States \cr

L2: Canada | Ontario \cr L2: United States | New York \cr L2: United States |
Pennsylvania \cr

L3: Canada | Ontario | Ottawa \cr L3: Canada | Ontario | Toronto \cr L3:
United States | New York | New York \cr L3: United States | Pennsylvania |
Philadelphia
}
\examples{
data(ne_raw)
data(ne_ref)

# find all non-matches ("anti"-join) at each hierarchical level
spmatch_best(ne_raw, ne_ref, type = "resolve_anti", fuzzy = TRUE)

# find all matches ("inner"-join) at only the adm2 level
spmatch_best(ne_raw, ne_ref, type = "resolve_inner", levels = "adm2")

# with dictionary-based recoding
ne_dict <- data.frame(value = "USA",
                      replacement = "United States",
                      variable = "adm0")

spmatch_best(ne_raw, ne_ref, type = "resolve_inner", dict = ne_dict, levels = "adm2")

}
