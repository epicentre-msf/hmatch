---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/"
)
options(digits = 4, width = 160)
```

# hmatch: Tools for cleaning and matching hierarchically-structured data
<!-- badges: start -->
[![Lifecycle: maturing](https://img.shields.io/badge/lifecycle-maturing-blue.svg)](https://www.tidyverse.org/lifecycle/#maturing)
[![Travis build status](https://travis-ci.org/epicentre-msf/hmatch.svg?branch=master)](https://travis-ci.org/epicentre-msf/hmatch)
[![Codecov test coverage](https://codecov.io/gh/epicentre-msf/hmatch/branch/master/graph/badge.svg)](https://codecov.io/gh/epicentre-msf/hmatch?branch=master)
<!-- badges: end -->

An R package for cleaning and matching messy hierarchical data (e.g.
hierarchically-nested adminstrative districts).


### Installation

Install from GitHub with:

```{r, eval=FALSE}
# install.packages("remotes")
remotes::install_github("epicentre-msf/hmatch")
```

### Example datasets

The `hmatch` package contains example datasets `ne_raw` (messy geographical
data) and `ne_ref` (reference data derived from a shapefile), based on a small
subset of northeastern North America.

```{r}
library(hmatch)

data(ne_raw)
data(ne_ref)

ne_raw # messy raw data

ne_ref # reference data derived from a shapefile
```

### Match messy hierarchically-structured data to a reference dataset

#### Complete matching

Each hierarchical level must match in sequence, with no missing values below the
match level.

```{r}
hmatch_complete(ne_raw, ne_ref)
```

The default join type is "left", but we can alternatively specify an "inner"
join, which will only return the rows of `raw` for which a single positive match
within `ref` is found.

```{r}
hmatch_complete(ne_raw, ne_ref, type = "inner")
```

Notice that in the first row (Suffolk County, New York), a match is made despite
the raw and reference data using different cases (lowercase vs. title case).
This is possible because, internally, all input strings are standardized prior
to matching (see `?string_standardization`).

#### Partial matching

Allows for missing values at one or more level below the match level.

```{r}
hmatch_partial(ne_raw, ne_ref)
```

Note that in the 4th row a match isn't made because of the discrepancy between
"USA" in `raw` and "United States" within `ref`. To overcome this we can use a
dictionary to internally recode "USA" during matching (see
`?dictionary_recoding` for more details).

```{r}
ne_dict <- data.frame(value = "USA",
                      replacement = "United States",
                      variable = "adm0")

hmatch_partial(ne_raw, ne_ref, dict = ne_dict)
```

#### Partial + fuzzy matching

Partial matching + fuzzy matching based on the
[stringdist](https://github.com/markvanderloo/stringdist) package.

```{r}
hmatch_partial(ne_raw, ne_ref, dict = ne_dict, fuzzy = TRUE, max_dist = 2)
```

#### Manual matching

Manually-specified matches, linking sets of hierarchical levels in the raw data
to a corresponding code column in the reference data.

```{r}
ne_man <- data.frame(adm0 = NA_character_,
                     adm1 = NA_character_,
                     adm2 = "NJ_Bergen",
                     hcode = "211",
                     stringsAsFactors = FALSE)

hmatch_manual(ne_raw, ne_ref, ne_man, code_col = "hcode")
```

#### Best-possible matching

Identify potential matches at each successive level, starting with only the
first level, then the first and second level, etc. The best-possible match then
reflects the highest-level that is consistent among all possible matches to the
given row of raw data.

```{r}
hmatch_best(raw = ne_raw, ref = ne_ref, fuzzy = TRUE)
```

#### The all-strategies approach

Implement all matching strategies in turn, from most to least strict:

1. (optional) manually-specified matching with `hmatch_manual()`
2. complete matching with `hmatch_complete()`
3. partial matching with `hmatch_partial()`
4. fuzzy partial matching with `hmatch_partial(..., fuzzy = TRUE)`
5. best-possible matching with `hmatch_best()`

```{r}
hmatch(raw = ne_raw,
       ref = ne_ref,
       man = ne_man,
       dict = ne_dict,
       fuzzy = TRUE,
       code_col = "hcode")
```


### Generate unique codes for each level in a reference dataset

Functions `hcodes_int()` and `hcodes_str()` can be used to create integer- or
string-based codes, respectively.

```{r}
ne_ref$hcode_str <- hcodes_str(ne_ref, pattern = "^adm")
ne_ref
```

